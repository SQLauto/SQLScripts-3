--ALTER proc STATS_GetSQLLogInfo

--(    @LOGS_TO_LOAD           INT = 0  -- BASED ON RESETTING LOG DAILY, CAN LOAD UP TO 7 DAYS.  IF YOU DON'T RESET YOUR LOG, ENTER '1'
--   , @LAST_24_HOURS          BIT = 1  -- OVERRIDES @LOGS_TO_LOAD TO 2, THEN FILTERS RESULTS FOR 24 HOUR PERIOD

--   , @SHOW_DETAIL            BIT = 0  -- STRAIGHT LIST OF THE ERROR LOG
--   , @SHOW_SUMMARY           BIT = 0  -- SUMMARIZED ERROR LOG, COUNTING EVENTS BY DAY, HOUR, AND CATEGORY.
--   , @SHOW_BACKUP_SUMMARY    BIT = 0 
--   , @SHOW_BACKUP_DETAIL     BIT = 0  -- ONLY WANT TO SEE BACKUP DETAILS IF THERE'S A PROBLEM.  ONLY PROBLEM DETAILS ARE INCLUDED.
--   , @SHOW_LOGON             BIT = 0  -- LOGON SUMMARY AND DETAIL.
--   , @SHOW_LOGINIT           BIT = 0  -- NOT SURE WHY YOU WOULD EVER JUST WANT TO SEE THE INFORMATIONAL AND LOG INITIALIZATION MESSAGES, BUT JUST IN CASE...
--   , @SHOW_OTHER             BIT = 0  -- ALL MESSAGES THAT COULDN'T BE CATEGORIZED.  JUST A STRAIGHT LIST.

--   , @SHOW_DEADLOCKS         BIT = 1
--   , @deadlocks_by_hour        bit = 0
--   , @deadlocks_by_proc        bit = 0
--   , @deadlock_winner_victim   bit = 0
--   , @deadlock_by_proc_by_hour bit = 0
--   , @deadlock_details         bit = 0
--)
--as
/* 
SQL LOG PARSER

PARSES THE SQL LOG FILES (NOT SQL AGENT).
PRIMARILY TO CHECK FOR DEADLOCKS, BUT ALSO PICKS UP OTHER ISSUES, INCLUDING BACKUP FAILURES, LOGIN ISSUES, AND 'OTHER'.

GENERALLY BACKUP INFO IS EXCLUDED, BECAUSE WE GET ALERTS WHEN BACKUPS FAIL ALREADY

ASSUMPTIONS:  SCRIPT WRITTEN ASSUMING THAT THE LOG IS RESEEDED DAILY JUST BEFORE MIDNIGHT.  WE KEEP 7 DAYS OF LOGS.

*/

BEGIN -- INITIAL LOGIC

SET NOCOUNT ON

--BEGIN -- VARIABLE DECLARATION
    DECLARE @LOGS_TO_LOAD             INT = 1  -- BASED ON RESETTING LOG DAILY, CAN LOAD UP TO 7 DAYS.  IF YOU DON'T RESET YOUR LOG, ENTER '1'
    DECLARE @LAST_24_HOURS            BIT = 0  -- OVERRIDES @LOGS_TO_LOAD TO 2, THEN FILTERS RESULTS FOR 24 HOUR PERIOD
                                      
    DECLARE @SHOW_DETAIL              BIT = 0  -- STRAIGHT LIST OF THE ERROR LOG
    DECLARE @SHOW_SUMMARY             BIT = 1  -- SUMMARIZED ERROR LOG, COUNTING EVENTS BY DAY, HOUR, AND CATEGORY.
                                      
    DECLARE @SHOW_DEADLOCKS           BIT = 1
    declare @deadlocks_by_hour        bit = 0
    declare @deadlocks_by_proc        bit = 1
    declare @deadlock_winner_victim   bit = 1
    declare @deadlock_by_proc_by_hour bit = 0
    declare @deadlock_details         bit = 1
    --DECLARE @RUN_PHYS_STATS         BIT = 0  -- PULLS FRAGMENTATION FOR INDICES INVOLVED IN DEADLOCKS.  MAY NOT WANT TO DO SO DEPENDING ON SERVER LOAD.
    DECLARE @SHOW_BACKUP_SUMMARY    BIT = 0 
    DECLARE @SHOW_BACKUP_DETAIL     BIT = 0  -- ONLY WANT TO SEE BACKUP DETAILS IF THERE'S A PROBLEM.  ONLY PROBLEM DETAILS ARE INCLUDED.
    DECLARE @SHOW_LOGON             BIT = 0  -- LOGON SUMMARY AND DETAIL.
    DECLARE @SHOW_LOGINIT           BIT = 0  -- NOT SURE WHY YOU WOULD EVER JUST WANT TO SEE THE INFORMATIONAL AND LOG INITIALIZATION MESSAGES, BUT JUST IN CASE...
    DECLARE @SHOW_OTHER             BIT = 0  -- ALL MESSAGES THAT COULDN'T BE CATEGORIZED.  JUST A STRAIGHT LIST.

--END

BEGIN /* TEMP TABLE CREATION*/
    IF OBJECT_ID(N'TEMPDB..#ERROR_LOG') IS NOT NULL DROP TABLE #ERROR_LOG
    IF OBJECT_ID(N'TEMPDB..#LOG_INIT') IS NOT NULL DROP TABLE #LOG_INIT
    IF OBJECT_ID(N'TEMPDB..#LOG_INIT2') IS NOT NULL DROP TABLE #LOG_INIT2
    IF OBJECT_ID(N'TEMPDB..#SUMMARY') IS NOT NULL DROP TABLE #SUMMARY
    IF OBJECT_ID(N'TEMPDB..#BACKUP_DETAIL') IS NOT NULL DROP TABLE #BACKUP_DETAIL
    IF OBJECT_ID(N'TEMPDB..#TOTAL_BACKUP') IS NOT NULL DROP TABLE #TOTAL_BACKUP
    IF OBJECT_ID(N'TEMPDB..#NOT_SUCCESSFUL_BACKUP') IS NOT NULL DROP TABLE #NOT_SUCCESSFUL_BACKUP
    IF OBJECT_ID(N'TEMPDB..#TOTAL_BACKUP2') IS NOT NULL DROP TABLE #TOTAL_BACKUP2
    IF OBJECT_ID(N'TEMPDB..#LOGON_DETAIL') IS NOT NULL DROP TABLE #LOGON_DETAIL


    CREATE TABLE #ERROR_LOG
    (ERROR_LOG_ID INT IDENTITY (1, 1)
    , CREATION_DATETIME DATETIME
    , PROCESS_ID NVARCHAR(50)
    , TEXT NVARCHAR(MAX)
    , FILE_NBR TINYINT
    , CATEGORY NVARCHAR(50))

    CREATE TABLE #LOG_INIT
    (
     FILE_NBR TINYINT
    ,FIRST_LOG INT
    )

    CREATE TABLE #LOG_INIT2
    (
     FILE_NBR TINYINT
    ,ERROR_LOG_ID INT
    ,PROCESS_ID NVARCHAR(50)
    ,CREATION_DATETIME DATETIME
    )

    CREATE TABLE #SUMMARY
    (
     OUTPUT_TYPE NVARCHAR(30)
  --  , DOW_NAME NVARCHAR(20)
    ,LOG_DATE DATE
    ,LOG_HOUR INT
    ,DATE_FROM DATETIME
    ,DATE_TO DATETIME
    ,MINUTES_FROM_TO_TO INT
    ,CATEGORY VARCHAR(20)
    ,MESSAGE_COUNT INT
    ,MESSAGES_PER_MINUTE DECIMAL(38,2)
    )

    CREATE TABLE #BACKUP_DETAIL
    (
     FILE_NBR TINYINT
    ,ERROR_LOG_ID INT
    ,PROCESS_ID NVARCHAR(50)
    ,CATEGORY VARCHAR(12)
    ,DB_NAME NVARCHAR(MAX)
    ,CREATION_DATETIME DATETIME
    ,SUCCESSFUL BIT
    ,TEXT NVARCHAR(MAX)
    )

    CREATE TABLE #LOGON_DETAIL
    (
     FILE_NBR TINYINT
    ,ERROR_LOG_ID INT
    ,PROCESS_ID NVARCHAR(50)
    ,USER_NAME NVARCHAR(MAX)
    ,CLIENT_NAME NVARCHAR(MAX)
    ,CREATION_DATETIME DATETIME
    ,TEXT NVARCHAR(MAX)
    )

END

BEGIN /* LOADING LOGS INTO TABLE*/
/* LOAD LOG INFO INTO TABLE.  INSERT IN THIS ORDER TO ENSURE THAT THE ERROR_LOG_IDS ARE IN LINE WITH CREATION_DATETIME*/

    IF @LAST_24_HOURS = 1 AND DATEPART(DW, GETDATE()) <> 2 SET @LOGS_TO_LOAD = 2
    IF @LAST_24_HOURS = 1 AND DATEPART(DW, GETDATE()) =  2 SET @LOGS_TO_LOAD = 4

    IF @LOGS_TO_LOAD >= 7
        BEGIN
            INSERT INTO #ERROR_LOG (CREATION_DATETIME, PROCESS_ID, TEXT)
                  EXEC MASTER.DBO.XP_READERRORLOG 6, 1  -- THIRD LOG, MAIN SQL LOG (NOT SQL AGENT)

            UPDATE #ERROR_LOG SET FILE_NBR = 6 WHERE FILE_NBR IS NULL
        END

    IF @LOGS_TO_LOAD >= 6
        BEGIN
            INSERT INTO #ERROR_LOG (CREATION_DATETIME, PROCESS_ID, TEXT)
                  EXEC MASTER.DBO.XP_READERRORLOG 5, 1  -- THIRD LOG, MAIN SQL LOG (NOT SQL AGENT)

            UPDATE #ERROR_LOG SET FILE_NBR = 5 WHERE FILE_NBR IS NULL
        END

    IF @LOGS_TO_LOAD >= 5
        BEGIN
            INSERT INTO #ERROR_LOG (CREATION_DATETIME, PROCESS_ID, TEXT)
                  EXEC MASTER.DBO.XP_READERRORLOG 4, 1  -- THIRD LOG, MAIN SQL LOG (NOT SQL AGENT)

            UPDATE #ERROR_LOG SET FILE_NBR = 4 WHERE FILE_NBR IS NULL
        END

    IF @LOGS_TO_LOAD >= 4
        BEGIN
            INSERT INTO #ERROR_LOG (CREATION_DATETIME, PROCESS_ID, TEXT)
                  EXEC MASTER.DBO.XP_READERRORLOG 3, 1  -- THIRD LOG, MAIN SQL LOG (NOT SQL AGENT)

            UPDATE #ERROR_LOG SET FILE_NBR = 3 WHERE FILE_NBR IS NULL
        END

    IF @LOGS_TO_LOAD >= 3
        BEGIN
            INSERT INTO #ERROR_LOG (CREATION_DATETIME, PROCESS_ID, TEXT)
                  EXEC MASTER.DBO.XP_READERRORLOG 2, 1  -- THIRD LOG, MAIN SQL LOG (NOT SQL AGENT)

            UPDATE #ERROR_LOG SET FILE_NBR = 2 WHERE FILE_NBR IS NULL
        END

    IF @LOGS_TO_LOAD >= 2
        BEGIN
            INSERT INTO #ERROR_LOG (CREATION_DATETIME, PROCESS_ID, TEXT)
                  EXEC MASTER.DBO.XP_READERRORLOG 1, 1  -- THIRD LOG, MAIN SQL LOG (NOT SQL AGENT)

            UPDATE #ERROR_LOG SET FILE_NBR = 1 WHERE FILE_NBR IS NULL
        END

    IF @LOGS_TO_LOAD >= 1
        BEGIN
            INSERT INTO #ERROR_LOG (CREATION_DATETIME, PROCESS_ID, TEXT)
                  EXEC MASTER.DBO.XP_READERRORLOG 0, 1  -- THIRD LOG, MAIN SQL LOG (NOT SQL AGENT)

            UPDATE #ERROR_LOG SET FILE_NBR = 0 WHERE FILE_NBR IS NULL
        END


   IF @LAST_24_HOURS = 1 AND DATEPART(DW, GETDATE()) <> 2
      BEGIN
         DELETE FROM #ERROR_LOG WHERE CREATION_DATETIME < GETDATE() - 1
      END

   IF @LAST_24_HOURS = 1 AND DATEPART(DW, GETDATE()) = 2
      BEGIN
         DELETE FROM #ERROR_LOG WHERE CREATION_DATETIME < GETDATE() - 3
      END

    INSERT INTO #LOG_INIT
        SELECT FILE_NBR, MIN(ERROR_LOG_ID) AS FIRST_LOG
        FROM #ERROR_LOG
        GROUP BY FILE_NBR

    INSERT INTO #LOG_INIT2  
        SELECT FILE_NBR, ERROR_LOG_ID, PROCESS_ID, CREATION_DATETIME
        FROM #ERROR_LOG      
        WHERE ERROR_LOG_ID IN (SELECT FIRST_LOG FROM #LOG_INIT)

    UPDATE EL
    SET CATEGORY = 'LOG INIT/INFO' 
    FROM #ERROR_LOG EL
    JOIN #LOG_INIT2 LI ON LI.FILE_NBR = EL.FILE_NBR 
                        AND LI.PROCESS_ID = EL.PROCESS_ID
                        AND EL.CREATION_DATETIME BETWEEN LI.CREATION_DATETIME AND DATEADD(MS, 500, LI.CREATION_DATETIME)


    UPDATE #ERROR_LOG
    SET CATEGORY = CASE WHEN PROCESS_ID = 'BACKUP' THEN 'BACKUP'
                       WHEN PROCESS_ID = 'LOGON' THEN 'LOGON'
                       WHEN PROCESS_ID = 'SPID7S' THEN 'DEADLOCK - 1204'
                       WHEN PROCESS_ID LIKE '%S' 
                            AND PROCESS_ID <> 'SPID7S'
                            AND TEXT NOT LIKE 'THIS INSTANCE OF SQL SERVER HAS BEEN USING%' 
                            AND TEXT NOT LIKE 'THIS INSTANCE OF SQL SERVER HAS BEEN USING%' 
                            AND TEXT NOT LIKE 'SQL SERVER HAS ENCOUNTERED %'  --  OF I/O REQUESTS TAKING LONGER THAN 15 SECONDS TO COMPLETE
                            AND TEXT NOT LIKE 'FLUSHCACHE%' 
                            AND TEXT NOT LIKE '            AVERAGE THROUGHPUT:%'
                            AND TEXT NOT LIKE '            LAST TARGET OUTSTANDING:%'
                           THEN 'DEADLOCK - 1222'
                       WHEN TEXT LIKE '%THIS IS AN INFORMATIONAL MESSAGE%' THEN 'LOG INIT/INFO'
                       WHEN TEXT = '(C) MICROSOFT CORPORATION.' THEN 'LOG INIT/INFO' 
                       WHEN TEXT LIKE 'ATTEMPTING TO CYCLE ERROR LOG%' THEN 'LOG INIT/INFO' 
                       WHEN TEXT LIKE 'THIS INSTANCE OF SQL SERVER HAS BEEN USING A PROCESS%' THEN 'LOG INIT/INFO' 
                       ELSE 'OTHER' END 
    WHERE CATEGORY IS NULL

END 


BEGIN /* BASIC DATA EXPLORATION*/
    ----SELECT DISTINCT PROCESS_ID FROM #ERROR_LOG
    ----ORDER BY PROCESS_ID

    --SELECT * FROM #ERROR_LOG
    --WHERE PROCESS_ID NOT LIKE '%S' AND TEXT LIKE '%DEADLOCK%'
    --ORDER BY ERROR_LOG_ID

--SELECT * FROM #ERROR_LOG WHERE CATEGORY <> 'BACKUP'

    ----SELECT * FROM #ERROR_LOG
    ----WHERE TEXT LIKE 'THIS INSTANCE OF SQL SERVER HAS BEEN USING%'
    ----ORDER BY ERROR_LOG_ID
    PRINT '' -- I NEED SOMETHING IN THE BEGIN-END BLOCK WHEN THE SELECT QUERIES ARE COMMENTED OUT.
END

IF @SHOW_DETAIL = 1     
    BEGIN
        SELECT * 
        FROM #ERROR_LOG
        WHERE CATEGORY LIKE '%DEADLOCK - 1222%'
        ORDER BY ERROR_LOG_ID
    END

IF @SHOW_SUMMARY = 1    
/* BIG PICTURE - WAS THERE A DAY WHEN WE GOT A LOT MORE MESSAGES THAN USUAL?*/
    BEGIN
        INSERT INTO #SUMMARY
            SELECT 'HOURLY COUNT' AS OUTPUT_TYPE
           -- ,  DOW_NAME
            , CAST(CREATION_DATETIME AS DATE) AS LOG_DATE
            , DATEPART(HOUR,  CREATION_DATETIME) AS LOG_HOUR
            , MIN(CREATION_DATETIME) AS DATE_FROM
            , MAX(CREATION_DATETIME) AS DATE_TO
            , DATEDIFF(MINUTE, MIN(CREATION_DATETIME), MAX(CREATION_DATETIME))  AS MINUTES_FROM_TO_TO
            , CATEGORY
            , COUNT(*) AS MESSAGE_COUNT
            , CAST(COUNT(*) AS DECIMAL(38, 2)) / 60  MESSAGES_PER_MINUTE
            FROM #ERROR_LOG EL
           -- JOIN DBA.DBO.DIM_DATE DT ON DT.DT = CAST(CREATION_DATETIME AS DATE)
            GROUP BY -- DOW_NAME
            --, 
CAST(CREATION_DATETIME AS DATE)
            , DATEPART(HOUR,  CREATION_DATETIME)
            , CATEGORY

        SELECT 'OVERALL SUMMARY' AS OUTPUT
    --    , S.DOW_NAME
        , S.LOG_DATE
        , S.LOG_HOUR
        , SUM(S.MESSAGE_COUNT) AS TOTAL_LOG_ENTRIES
        , SUM(S.MESSAGES_PER_MINUTE) AS TOTAL_LOG_ENTRIES_PER_MINUTE
        , COALESCE(LI.MESSAGE_COUNT, 0) AS LOGINIT_OR_INFO_MESSAGES
        , COALESCE(BAC.MESSAGE_COUNT, 0) AS BACKUP_MESSAGES
        , COALESCE(LGN.MESSAGE_COUNT, 0)  AS LOGON_MESSAGES
        , COALESCE(DLK1.MESSAGE_COUNT, 0)  AS DEADLOCK_1204_MESSAGES
        , COALESCE(DLK2.MESSAGE_COUNT, 0)  AS DEADLOCK_1222_MESSAGES
        , COALESCE(OTHER.MESSAGE_COUNT, 0)  AS OTHER_MESSAGES
        FROM #SUMMARY S
         LEFT JOIN (SELECT * FROM #SUMMARY WHERE CATEGORY = 'BACKUP') AS BAC ON BAC.LOG_DATE = S.LOG_DATE AND BAC.LOG_HOUR = S.LOG_HOUR
         LEFT JOIN (SELECT * FROM #SUMMARY WHERE CATEGORY = 'LOGON') AS LGN ON LGN.LOG_DATE = S.LOG_DATE AND LGN.LOG_HOUR = S.LOG_HOUR
         LEFT JOIN (SELECT * FROM #SUMMARY WHERE CATEGORY = 'DEADLOCK - 1204') AS DLK1 ON DLK1.LOG_DATE = S.LOG_DATE AND DLK1.LOG_HOUR = S.LOG_HOUR
         LEFT JOIN (SELECT * FROM #SUMMARY WHERE CATEGORY = 'DEADLOCK - 1222') AS DLK2 ON DLK2.LOG_DATE = S.LOG_DATE AND DLK2.LOG_HOUR = S.LOG_HOUR
         LEFT JOIN (SELECT * FROM #SUMMARY WHERE CATEGORY = 'LOG INIT/INFO') AS LI ON LI.LOG_DATE = S.LOG_DATE AND LI.LOG_HOUR = S.LOG_HOUR
         LEFT JOIN (SELECT * FROM #SUMMARY WHERE CATEGORY = 'OTHER') AS OTHER ON OTHER.LOG_DATE = S.LOG_DATE AND OTHER.LOG_HOUR = S.LOG_HOUR
        GROUP BY -- S.DOW_NAME
        S.LOG_DATE
        , S.LOG_HOUR
        , BAC.MESSAGE_COUNT
        , LGN.MESSAGE_COUNT
        , DLK1.MESSAGE_COUNT 
        , DLK2.MESSAGE_COUNT 
        , OTHER.MESSAGE_COUNT
        , LI.MESSAGE_COUNT
        ORDER BY  S.LOG_DATE, S.LOG_HOUR
    END

IF @SHOW_BACKUP_SUMMARY = 1    
    BEGIN 
       INSERT INTO #BACKUP_DETAIL
            SELECT FILE_NBR
            , ERROR_LOG_ID
            , PROCESS_ID
            , CASE WHEN PROCESS_ID = 'BACKUP' AND TEXT LIKE 'LOG%' THEN 'LOG BACKUP'
                            WHEN TEXT LIKE '%DIFFERENTIAL%' THEN 'DIFFERENTIAL'
                            WHEN PROCESS_ID = 'BACKUP' AND TEXT NOT LIKE 'LOG%' THEN 'FULL BACKUP' END AS CATEGORY
           -- , SUBSTRING(TEXT, CHARINDEX(':', TEXT) + 2, CHARINDEX(',', TEXT) - CHARINDEX(':', TEXT) - 2) 
            , 'x' AS DB_NAME
            , CREATION_DATETIME
            , CASE WHEN TEXT LIKE 'LOG WAS BACKED UP%' THEN 1
                   WHEN TEXT LIKE 'DATABASE DIFFERENTIAL CHANGES WERE BACKED UP%' THEN 1
                   WHEN TEXT LIKE 'DATABASE BACKED UP%' THEN 1
                   ELSE 0 END AS SUCCESSFUL
            , TEXT
            FROM #ERROR_LOG
            WHERE PROCESS_ID = 'BACKUP'
            ORDER BY ERROR_LOG_ID

        SELECT Y.NAME AS DB_NAME
         , BACKUP_CATEGORY
         , STATE_DESC
         , RECOVERY_MODEL
         , MIN(CREATION_DATETIME) AS DATE_FROM
         , MAX(CREATION_DATETIME) AS DATE_TO
         , CASE WHEN  MAX(CREATION_DATETIME)  IS NULL THEN 0 ELSE COUNT(*) END AS MESSAGE_COUNT
        INTO #TOTAL_BACKUP
        FROM (SELECT NAME, BACKUP_CATEGORY, STATE_DESC, RECOVERY_MODEL_DESC AS RECOVERY_MODEL 
               FROM SYS.DATABASES D 
               CROSS JOIN (SELECT 'LOG BACKUP' AS BACKUP_CATEGORY 
                           UNION ALL SELECT 'DIFFERENTIAL' 
                           UNION ALL SELECT 'FULL BACKUP') X 
             ) Y
         LEFT JOIN #BACKUP_DETAIL BD ON BD.DB_NAME = Y.NAME AND BD.CATEGORY = Y.BACKUP_CATEGORY
        GROUP BY BACKUP_CATEGORY, Y.NAME , STATE_DESC, RECOVERY_MODEL
        ORDER BY BACKUP_CATEGORY, DB_NAME

        SELECT Y.NAME AS DB_NAME, BACKUP_CATEGORY,  MIN(CREATION_DATETIME) AS DATE_FROM, MAX(CREATION_DATETIME) AS DATE_TO, COUNT(*) AS MESSAGE_COUNT
        INTO #NOT_SUCCESSFUL_BACKUP
        FROM (SELECT NAME, BACKUP_CATEGORY FROM SYS.DATABASES D CROSS JOIN (SELECT 'LOG BACKUP' AS BACKUP_CATEGORY UNION ALL SELECT 'DIFFERENTIAL' UNION ALL SELECT 'FULL BACKUP') X ) Y
        JOIN #BACKUP_DETAIL BD ON BD.DB_NAME = Y.NAME AND BD.CATEGORY = Y.BACKUP_CATEGORY 
        WHERE SUCCESSFUL = 0
        GROUP BY BACKUP_CATEGORY, Y.NAME
        ORDER BY BACKUP_CATEGORY, DB_NAME

         SELECT TB.DB_NAME
         , TB.BACKUP_CATEGORY
         , TB.STATE_DESC AS DB_STATUS
         , TB.RECOVERY_MODEL
         , TB.DATE_FROM AS FIRST_MESSAGE_DATETIME
         , TB.DATE_TO AS LAST_MESSAGE_DATETIME
         , COALESCE(TB.MESSAGE_COUNT, 0) AS TOTAL_MESSAGE_COUNT
         , COALESCE(NSB.MESSAGE_COUNT, 0) AS OTHER_MESSAGE_COUNT
         , COALESCE(TB.MESSAGE_COUNT, 0) - COALESCE(NSB.MESSAGE_COUNT, 0) AS SUCCESS_MESSAGE_COUNT
         INTO #TOTAL_BACKUP2
          FROM #TOTAL_BACKUP TB 
         LEFT JOIN #NOT_SUCCESSFUL_BACKUP NSB ON NSB.DB_NAME = TB.DB_NAME AND NSB.BACKUP_CATEGORY = TB.BACKUP_CATEGORY

         SELECT DISTINCT 'BACKUP SUMMARY' AS OUTPUT
         , DB_NAME 
         , DB_STATUS    
         , RECOVERY_MODEL

         , (SELECT SUM(OTHER_MESSAGE_COUNT) FROM #TOTAL_BACKUP2 TB2 WHERE TB2.DB_NAME= TB.DB_NAME) AS TOTAL_OTHER_MSG
         , (SELECT DATE_FROM FROM #NOT_SUCCESSFUL_BACKUP TB2 WHERE  TB2.DB_NAME = TB.DB_NAME) AS FIRST_OTHER_DATETIME
         , (SELECT DATE_TO FROM #NOT_SUCCESSFUL_BACKUP TB2 WHERE  TB2.DB_NAME = TB.DB_NAME) AS LAST_OTHER_DATETIME

      --   , (SELECT TOTAL_MESSAGE_COUNT FROM #TOTAL_BACKUP2 TB2 WHERE BACKUP_CATEGORY = 'FULL BACKUP' AND  TB2.DB_NAME = TB.DB_NAME) AS FULL_BACKUP_MSGS
         , (SELECT SUCCESS_MESSAGE_COUNT FROM #TOTAL_BACKUP2 TB2 WHERE BACKUP_CATEGORY = 'FULL BACKUP' AND  TB2.DB_NAME = TB.DB_NAME) AS FULL_BACKUP_SUCCESSES
         , (SELECT OTHER_MESSAGE_COUNT FROM #TOTAL_BACKUP2 TB2 WHERE BACKUP_CATEGORY = 'FULL BACKUP' AND  TB2.DB_NAME = TB.DB_NAME) AS FULL_BACKUP_OTHER

      --   , (SELECT TOTAL_MESSAGE_COUNT FROM #TOTAL_BACKUP2 TB2 WHERE BACKUP_CATEGORY = 'DIFFERENTIAL' AND  TB2.DB_NAME = TB.DB_NAME) AS DIFF_BACKUP_MSGS
         , (SELECT SUCCESS_MESSAGE_COUNT FROM #TOTAL_BACKUP2 TB2 WHERE BACKUP_CATEGORY = 'DIFFERENTIAL' AND  TB2.DB_NAME = TB.DB_NAME) AS DIFF_BACKUP_SUCCESSES
         , (SELECT OTHER_MESSAGE_COUNT FROM #TOTAL_BACKUP2 TB2 WHERE BACKUP_CATEGORY = 'DIFFERENTIAL' AND  TB2.DB_NAME = TB.DB_NAME) AS DIFF_BACKUP_OTHER

     --    , (SELECT TOTAL_MESSAGE_COUNT FROM #TOTAL_BACKUP2 TB2 WHERE BACKUP_CATEGORY = 'LOG BACKUP' AND  TB2.DB_NAME = TB.DB_NAME) AS LOG_BACKUP_MSGS
         , (SELECT SUCCESS_MESSAGE_COUNT FROM #TOTAL_BACKUP2 TB2 WHERE BACKUP_CATEGORY = 'LOG BACKUP' AND  TB2.DB_NAME = TB.DB_NAME) AS LOG_BACKUP_SUCCESSES
         , (SELECT OTHER_MESSAGE_COUNT FROM #TOTAL_BACKUP2 TB2 WHERE BACKUP_CATEGORY = 'LOG BACKUP' AND  TB2.DB_NAME = TB.DB_NAME) AS LOG_BACKUP_OTHER

         , CASE WHEN DB_NAME IN ('MASTER', 'MODEL', 'MSDB', 'TEMPDB') THEN 1 ELSE 0 END AS IS_SYSTEM_DB
         FROM #TOTAL_BACKUP2 TB
         ORDER BY CASE WHEN DB_NAME IN ('MASTER', 'MODEL', 'MSDB', 'TEMPDB') THEN 1 ELSE 0 END desc, DB_NAME
     END  -- IF @SHOW_BACKUP_SUMMARY = 1  
      
--IF @SHOW_BACKUP_DETAIL = 1
--      BEGIN

--        IF (SELECT COUNT(*) FROM #BACKUP_DETAIL) = 0
--           BEGIN
--               INSERT INTO #BACKUP_DETAIL
--               SELECT FILE_NBR
--               , ERROR_LOG_ID
--               , PROCESS_ID
--               , CASE WHEN PROCESS_ID = 'BACKUP' AND TEXT LIKE 'LOG%' THEN 'LOG BACKUP'
--                               WHEN TEXT LIKE '%DIFFERENTIAL%' THEN 'DIFFERENTIAL'
--                               WHEN PROCESS_ID = 'BACKUP' AND TEXT NOT LIKE 'LOG%' THEN 'FULL BACKUP' END AS CATEGORY
--               , SUBSTRING(TEXT, CHARINDEX(':', TEXT) + 2, CHARINDEX(',', TEXT) - CHARINDEX(':', TEXT) - 2) AS DB_NAME
--               , CREATION_DATETIME
--               , CASE WHEN TEXT LIKE 'LOG WAS BACKED UP%' THEN 1
--                      WHEN TEXT LIKE 'DATABASE DIFFERENTIAL CHANGES WERE BACKED UP%' THEN 1
--                      WHEN TEXT LIKE 'DATABASE BACKED UP%' THEN 1
--                      ELSE 0 END AS SUCCESSFUL
--               , TEXT
--               FROM #ERROR_LOG
--               WHERE PROCESS_ID = 'BACKUP'
--               ORDER BY ERROR_LOG_ID
--            END

--        IF EXISTS (SELECT * FROM #BACKUP_DETAIL WHERE SUCCESSFUL = 0)
--         BEGIN
--           SELECT 'BACKUP DETAILS - NOT SUCCESSFUL' AS OUTPUT, * FROM #BACKUP_DETAIL WHERE SUCCESSFUL = 0
--         END 
--        ELSE
--         BEGIN
--          SELECT 'BACKUP DETAIL - ALL MESSAGES LOGGED SUCCESSFUL BACKUPS.' AS OUTPUT
--         END
--      END 


IF @SHOW_LOGON = 1      
    BEGIN   
       INSERT INTO #LOGON_DETAIL  
            SELECT FILE_NBR
            , ERROR_LOG_ID
            , PROCESS_ID
            , CASE WHEN TEXT LIKE '%USER%' THEN SUBSTRING(TEXT, CHARINDEX('''', TEXT) + 1, (CHARINDEX('.', TEXT)-1) - CHARINDEX('''', TEXT) - 1) ELSE '' END AS USER_NAME
            , CASE WHEN TEXT LIKE '%CLIENT%' THEN SUBSTRING(TEXT, CHARINDEX('[', TEXT) + 1, CHARINDEX(']', TEXT) - CHARINDEX('[', TEXT) - 1) END AS CLIENT_NAME
            , CREATION_DATETIME
            , TEXT
            FROM #ERROR_LOG
            WHERE PROCESS_ID = 'LOGON'
            ORDER BY ERROR_LOG_ID

        SELECT 'LOGON SUMMARY' AS OUTPUT, USER_NAME, CLIENT_NAME, MIN(CREATION_DATETIME) AS DATE_FROM, MAX(CREATION_DATETIME) AS DATE_TO, COUNT(*) AS MESSAGE_COUNT
        FROM #LOGON_DETAIL
        GROUP BY USER_NAME, CLIENT_NAME
        ORDER BY USER_NAME, CLIENT_NAME

        SELECT 'LOGON DETAIL' AS OUTPUT,* FROM #LOGON_DETAIL

    END

IF @SHOW_LOGINIT = 1    
    BEGIN
        SELECT 'LOGINIT' AS OUTPUT, * 
        FROM #ERROR_LOG
        WHERE CATEGORY = 'LOG INIT/INFO'
        ORDER BY ERROR_LOG_ID
    END

IF @SHOW_OTHER = 1      
    BEGIN
        SELECT 'OTHER MESSAGES' AS OUTPUT, * 
        FROM #ERROR_LOG
        WHERE CATEGORY = 'OTHER'
        ORDER BY ERROR_LOG_ID
    END

IF @SHOW_DEADLOCKS = 1  
    BEGIN  
        /*  I'M TAKING FULL ADVANTAGE OF THE OBSERVATION THAT ALL DEADLOCK PROCESS_IDS ARE 'SPIDXXXS'.
            FROM WHAT I'VE SEEN, THE ONLY OTHER MESSAGES THAT HAVE THAT FORM ARE 'THIS INSTANCE OF SQL SERVER HAS BEEN USING 
                A PROCESS ID OF 6172 SINCE 5/5/2013 9:35:36 AM. THIS IS AN INFORMATIONAL MESSAGE ONLY; NO USER ACTION IS REQUIRED.'
            THIS OBSERVATION COULD BE INVALID, BUT IT APPLIED TO A WEEK'S WORTH OF LOGS THAT I'M REVIEWING.  IF IT'S WRONG, I'LL FIX IT WHEN I FIND IT.
               [SQL2012 ADDED ANOTHER = SPID28S, WITH A 3-ROW MESSAGE ABOUT FLUSHING THE CACHE, E.G.
                  FLUSHCACHE: CLEANED UP 11155 BUFS WITH 9350 WRITES IN 245060 MS (AVOIDED 8502 NEW DIRTY BUFS) FOR DB 13:0
                              AVERAGE THROUGHPUT:   0.36 MB/SEC, I/O SATURATION: 11542, CONTEXT SWITCHES 22465
                              LAST TARGET OUTSTANDING: 8758, AVGWRITELATENCY 15
               ]

            ONCE I PULL THOSE MESSAGES, I HAVE TO FIGURE OUT WHICH ROWS GO TOGETHER, SINCE THERE IS NO CONCEPT OF A BATCH_ID
            THAT TIES ALL THE ENTRIES FOR A SINGLE DEADLOCK INTO 1 UNIT.
          
            FOR NOW, THOUGH, I'M GOING TO GROUP MESSAGES BY SPID AND CREATION DATE, AND TAKE ADVANTAGE OF THE FACT THAT 1204 OUTPUTS START WITH 'DEADLOCK ENCOUNTERED .... PRINTING DEADLOCK INFORMATION'
            AND 1222 OUTPUTS START WITH 'DEADLOCK-LIST'.

            NOTE THAT CURRENTLY WE HAVE BOTH T-1204 AND T-1222 TURNED ON, AND SOMETIMES (BUT NOT ALWAYS), WE'RE GETTING 2 SETS OF MESSAGES.  
            QUERIES TO EXPLORE ARE BELOW, UNDER '6S VS...'
                RESULTS SHOW THAT ENTRIES WITH SPID7S ARE FROM 1204 .  ENTRIES WITH OTHER 'SPID###S' ENTRIES ARE FROM 1222  (AFTER CHECKING ONLINE).  
                SADLY, THERE ARE DEADLOCKS FROM 1204 THAT 1222 DOESN'T CAPTURE, SO I CAN'T JUST TOSS SPID7S.  THEY ALL SEEM TO BE INTRAPARALLELISM QUERIES, ON A VERY QUICK INITIAL REVIEW. 

                ANOTHER QUICK WAY TO TELL - 1204 OUTPUTS START WITH 'DEADLOCK ENCOUNTERED .... PRINTING DEADLOCK INFORMATION'
                                          - 1222 OUTPUTS START WITH 'DEADLOCK-LIST'
    
        */
        --------------------------------------------------------------------------------------------------------------------------------------------
        /* PULL ALL OF THE DETAILS OUT OF THE #ERROR_LOG TABLE SO THEY CAN BE MANIPULATED SEPARATELY*/
        IF OBJECT_ID(N'TEMPDB..#DEADLOCK_ENTRIES') IS NOT NULL DROP TABLE #DEADLOCK_ENTRIES

        SELECT * 
        INTO #DEADLOCK_ENTRIES
        FROM #ERROR_LOG 
        WHERE CATEGORY = 'DEADLOCK - 1222'

        --------------------------------------------------------------------------------------------------------------------------------------------

        BEGIN /*SOME DATA EXPLORATION TO SEE IF MY 2 SECOND RULE MAKES SENSE

        --------------------------------------------------------------------------------------------------------------------------------------------
            6S VS...   IT LOOKS AS IF WE HAVE THE SAME DEADLOCKS FROM -T1204 AND -T1222 AFTER ALL.  ONE ALWAYS SEEMS TO BE SPID7S.  VALIDATING....

            YOU KNOW, BEFORE I CAN REALLY DIVE INTO THIS, I HAVE TO RESOLVE THE BATCH ID ISSUE.  I JUST NEED TO HANDLE IT SEPARATELY FOR SPID7S AND EVERYTHING ELSE.
            OTHERWISE, THE QUERIES BELOW ARE TOO NARROW, LOOKING AT A SPECIFIC DATETIME DOWN TO THE MS.*/

            /* FIND CREATION DATETIMES WITH MORE THAN 1 PROCESS_ID */
           --IF OBJECT_ID(N'TEMPDB..#DL_A')    IS NOT NULL DROP TABLE #DL_A
           --IF OBJECT_ID(N'TEMPDB..#DL_B')    IS NOT NULL DROP TABLE #DL_B
           --IF OBJECT_ID(N'TEMPDB..#TEST')    IS NOT NULL DROP TABLE #TEST

           --SELECT PROCESS_ID, CREATION_DATETIME
           -- , SUM(CASE WHEN TEXT LIKE '%DEADLOCK ENCOUNTERED%' THEN 1 --TRACE 1204
           --            ELSE 0 END) AS DL_BEGIN_1204 
           -- , SUM(CASE WHEN TEXT LIKE '%DEADLOCK-LIST%' THEN 1 -- TRACE 1222
           --            ELSE 0 END) AS DL_BEGIN_1222 
           -- , COUNT(*) AS MESSAGE_COUNT, MIN(ERROR_LOG_ID) AS MIN_ERROR_LOG_ID, MAX(ERROR_LOG_ID) AS MAX_ERROR_LOG_ID
           -- INTO #DL_A
           -- FROM #DEADLOCK_ENTRIES
           -- WHERE PROCESS_ID <> 'SPID7S'
           -- GROUP BY PROCESS_ID, CREATION_DATETIME

           -- SELECT * , ROW_NUMBER() OVER(PARTITION BY CREATION_DATETIME ORDER BY PROCESS_ID ) AS ROW_NUM
           -- INTO #X
           -- FROM #DL_A 
           -- ORDER BY CREATION_DATETIME, PROCESS_ID

           --  /* THEN REVIEW THE OUTPUTS FOR THOSE DATETIMES WITH MORE THAN 1 SPID*/
           -- SELECT * FROM #DEADLOCK_ENTRIES
           -- WHERE CREATION_DATETIME IN (SELECT DISTINCT CREATION_DATETIME FROM #X WHERE ROW_NUM <> 1)
           -- ORDER BY CREATION_DATETIME, PROCESS_ID

           -- /* UNFORTUNATELY, THERE ARE SPID7S VALUES WITHOUT ANOTHER SPID AT THE SAME TIME*/
           -- SELECT CREATION_DATETIME 
           -- FROM #X
           -- GROUP BY CREATION_DATETIME
           -- HAVING MAX(ROW_NUM) = 1


           -- SELECT * FROM #DEADLOCK_ENTRIES
           -- WHERE PROCESS_ID <> 'SPID7S' 
           -- AND TEXT LIKE '%DEADLOCK ENCOUNTERED%'

           -- SELECT * FROM #DEADLOCK_ENTRIES
           -- WHERE CREATION_DATETIME BETWEEN '5/23/13 00:36' AND '5/23/13 00:37'
           -- ORDER BY ERROR_LOG_ID

            PRINT ''
        END

        --------------------------------------------------------------------------------------------------------------------------------------------

        /* ASSIGN BATCH_IDS TO THE DEADLOCKS*/
        /* HANDLE 1204 AND 1222 TRACE FLAGS SEPARATELY.  START WITH 1204*/
        BEGIN -- DEADLOCK 1222.  LOGIC IS IDENTICAL TO THAT USED FOR 1204  
        IF OBJECT_ID(N'TEMPDB..#T1222') IS NOT NULL DROP TABLE #T1222
        IF OBJECT_ID(N'TEMPDB..#T1222_A') IS NOT NULL DROP TABLE #T1222_A
        IF OBJECT_ID(N'TEMPDB..#T1222_B') IS NOT NULL DROP TABLE #T1222_B
        IF OBJECT_ID(N'TEMPDB..#BATCH_1222') IS NOT NULL DROP TABLE #BATCH_1222
        IF OBJECT_ID(N'TEMPDB..#Y_1222') IS NOT NULL DROP TABLE #Y_1222
        IF OBJECT_ID(N'TEMPDB..#Z_1222') IS NOT NULL DROP TABLE #Z_1222
        IF OBJECT_ID(N'TEMPDB..#T1222_WITH_BATCH') IS NOT NULL DROP TABLE #T1222_WITH_BATCH
        IF OBJECT_ID(N'TEMPDB..#NEED_TO_FIX_1222') IS NOT NULL DROP TABLE #NEED_TO_FIX_1222

           SELECT *
            INTO #T1222
            FROM #DEADLOCK_ENTRIES
            WHERE PROCESS_ID <> 'SPID7S'  -- DON'T GET SPID USED BY TRACE 1204

           SELECT PROCESS_ID, CREATION_DATETIME
            , SUM(CASE WHEN TEXT LIKE '%DEADLOCK-LIST%' THEN 1 -- TRACE 1222
                       ELSE 0 END) AS DL_BEGIN_1222 
            , COUNT(*) AS MESSAGE_COUNT
            , MIN(ERROR_LOG_ID) AS MIN_ERROR_LOG_ID
            , MAX(ERROR_LOG_ID) AS MAX_ERROR_LOG_ID
            , ROW_NUMBER() OVER(ORDER BY CREATION_DATETIME, PROCESS_ID) AS ROW_NUM
            INTO #T1222_A
            FROM #T1222
            GROUP BY PROCESS_ID, CREATION_DATETIME

            /*  --QUICK REVIEW.  WHERE DL_BEGIN = 1, IT'S A NEW DEADLOCK.  WHERE BEGIN = 0, MERGE WITH PRIOR ENTRY
            SELECT * 
            FROM #T1222_A
            ORDER BY CREATION_DATETIME*/

            /* WHEN DL_BEGIN_1222 = 0 (B/C CREATION DATETIME DIFFER BY MILLISECONDS), THE ROW NEEDS TO BE MERGED WITH THE PRIOR ROW.
               THE EXPECTATION IS THAT THE PROCESS LOG IDS MATCH, BUT THE COMPARISON IS ON THE ROW_NUM FUNCTION CALC'D ABOVE.  THE ASSUMPTION
               IS ALSO THAT THE ERROR_LOG_IDS WILL BE SEQUENTIAL, WHICH MAY NOT ALWAYS BE THE CASE.
               USE THE FOLLOWING QUERY TO FIND THOSE THAT DON'T MATCH.

            SELECT *
            FROM #T1222_A T1
            JOIN #T1222_A T2 ON T2.ROW_NUM = T1.ROW_NUM + 1       
            WHERE T1.DL_BEGIN_1222 = 1
            AND T2.DL_BEGIN_1222 = 0
            AND T1.MAX_ERROR_LOG_ID <> T2.MIN_ERROR_LOG_ID - 1
            */

            SELECT T1.PROCESS_ID, T1.CREATION_DATETIME, T1.DL_BEGIN_1222
            , T1.MESSAGE_COUNT + COALESCE(T2.MESSAGE_COUNT, 0) AS MESSAGE_COUNT
            , T1.MIN_ERROR_LOG_ID
            , COALESCE(T2.MAX_ERROR_LOG_ID, T1.MAX_ERROR_LOG_ID) AS MAX_ERROR_LOG_ID
            , ROW_NUMBER() OVER(ORDER BY T1.CREATION_DATETIME, T1.PROCESS_ID) AS BATCH_ID
            INTO #T1222_B
            FROM #T1222_A T1
            LEFT JOIN #T1222_A T2 ON T2.ROW_NUM = T1.ROW_NUM + 1    AND T2.DL_BEGIN_1222 = 0    
            AND T1.DL_BEGIN_1222 = 1
            AND T1.MAX_ERROR_LOG_ID = T2.MIN_ERROR_LOG_ID - 1
            WHERE T1.DL_BEGIN_1222 = 1

            /* ASSIGN THE BATCH IDS BACK TO THE DETAIL DATA*/
            SELECT T.*
            , CAST(NULL AS INT) AS BATCH_ID
            , CAST(NULL AS INT) AS BATCH_SEQUENCE_NUMBER
            INTO #T1222_WITH_BATCH
            FROM #T1222 T

            UPDATE TWB
            SET BATCH_ID = B.BATCH_ID
            FROM #T1222_WITH_BATCH TWB
            JOIN #T1222_B B ON  TWB.ERROR_LOG_ID BETWEEN B.MIN_ERROR_LOG_ID AND B.MAX_ERROR_LOG_ID
                                AND TWB.PROCESS_ID = B.PROCESS_ID

            IF OBJECT_ID(N'TEMPDB..#BATCH_TEMP') IS NOT NULL DROP TABLE #BATCH_TEMP
            SELECT 
             ERROR_LOG_ID 
            , BATCH_SEQUENCE_NUMBER = ROW_NUMBER() OVER(PARTITION BY BATCH_ID ORDER BY ERROR_LOG_ID )
            INTO #BATCH_TEMP
            FROM #T1222_WITH_BATCH

            UPDATE TWB
            SET BATCH_SEQUENCE_NUMBER = B.BATCH_SEQUENCE_NUMBER
            FROM #T1222_WITH_BATCH TWB
            JOIN #BATCH_TEMP B ON  TWB.ERROR_LOG_ID = B.ERROR_LOG_ID

            --SELECT * FROM #T1222_WITH_BATCH
            --ORDER BY BATCH_ID, BATCH_SEQUENCE_NUMBER

        END -- DEADLOCK 1222
     

        --------------------------------------------------------------------------------------------------------------------------------------------

        /* NOW THAT THE BATCH_IDS HAVE BEEN BEEN RESOLVED, SCRAPE THE TEXT TO PULL THE PROCS/INLINE SQL/ETC INVOLVED IN THE DEADLOCK.
            TWO COMPONENTS TO CONSIDER - PROCESSES (WHAT PROCS, INLINE SQL, ETC ARE THE WINNERS AND THE VICTIMS)
                                       - RESOURCES - WHAT TABLE, INDEX, ETC. WAS THE POINT OF CONTENTION?
           RESOURCES ARE A BIT SIMPLER TO MANAGE, SO WE START THERE.*/
        BEGIN -- FIND RESOURCES INVOLVED IN DEADLOCKS                
            /* LIMITING MYSELF TO PROCESS_ID <> 'SPID7S' BECAUSE INTRAPARALLELISM QUERIES AREN'T SOMETHING THAT WE CAN DO A LOT ABOUT, FROM A TEXT SCRAPING PERSPECTIVE.
               I'M GOING TO MIMIC THE SUMMARIZATION FOUND AT HTTP://BLOGS.MSDN.COM/B/BARTD/ARCHIVE/2006/09/08/DEADLOCK-TROUBLESHOOTING_2C00_-PART-1.ASPX  */
  
            /* FIND RESOURCES INVOLVED IN DEADLOCK*/
            IF OBJECT_ID(N'TEMPDB..#RESOURCE_LIST') IS NOT NULL DROP TABLE #RESOURCE_LIST
            IF OBJECT_ID(N'TEMPDB..#RESOURCE_LIST2') IS NOT NULL DROP TABLE #RESOURCE_LIST2
            IF OBJECT_ID(N'TEMPDB..#RESOURCE_LIST3') IS NOT NULL DROP TABLE #RESOURCE_LIST3
            IF OBJECT_ID(N'TEMPDB..#INDEX1') IS NOT NULL DROP TABLE #INDEX1

         /* IDENTIFY THE ROWS RELATED TO RESOURCES AND PROCESSES*/

         IF OBJECT_ID(N'TEMPDB..#RESOURCE') IS NOT NULL DROP TABLE #RESOURCE
         SELECT BATCH_ID, BATCH_SEQUENCE_NUMBER
         INTO #RESOURCE
         FROM #T1222_WITH_BATCH
         WHERE TEXT = '  RESOURCE-LIST'

         /* OWNING_PROCESS_RESOURCE COMBINES WITH #RESOURCE_LIST3 AFTER THE INDEX LOGIC IS DONE*/

         IF OBJECT_ID(N'TEMPDB..#OWNING_PROCESS') IS NOT NULL DROP TABLE #OWNING_PROCESS

         SELECT BATCH_ID, BATCH_SEQUENCE_NUMBER
         , CASE WHEN LEFT(LTRIM(REPLACE(TEXT, 'OWNER ID=', '')) , CHARINDEX(' ',LTRIM(REPLACE(TEXT, 'OWNER ID=', '')) )) <> '' 
                THEN LEFT(LTRIM(REPLACE(TEXT, 'OWNER ID=', '')) , CHARINDEX(' ',LTRIM(REPLACE(TEXT, 'OWNER ID=', '')) ))
                ELSE LTRIM(REPLACE(TEXT, 'OWNER ID=', '')) END AS PROCESS_NAME
         , TEXT
         INTO #OWNING_PROCESS
         FROM #T1222_WITH_BATCH
         WHERE TEXT LIKE '     OWNER ID=%'

         IF OBJECT_ID(N'TEMPDB..#OWNING_PROCESS_RESOURCE') IS NOT NULL DROP TABLE #OWNING_PROCESS_RESOURCE
         SELECT OP.BATCH_ID, OP.BATCH_SEQUENCE_NUMBER, PROCESS_NAME, T.ERROR_LOG_ID, T.TEXT
         INTO #OWNING_PROCESS_RESOURCE
         FROM #T1222_WITH_BATCH T
         JOIN #OWNING_PROCESS OP ON OP.BATCH_ID = T.BATCH_ID
         AND OP.BATCH_SEQUENCE_NUMBER = T.BATCH_SEQUENCE_NUMBER + 2
         ORDER BY BATCH_ID, BATCH_SEQUENCE_NUMBER



            SELECT BATCH_ID
            , ERROR_LOG_ID
            , CAST(LTRIM(LEFT(TEXT, CHARINDEX(' ', TEXT, 6))) AS NVARCHAR(50)) AS LOCK_TYPE
            , CAST(CASE WHEN TEXT LIKE '%MODE=%' THEN SUBSTRING(TEXT, CHARINDEX('MODE=', TEXT)+ 5, CHARINDEX(' ', TEXT, CHARINDEX('MODE=', TEXT)) - (CHARINDEX('MODE=', TEXT)+ 5)) END  AS NVARCHAR(50)) AS LOCK_MODE
            , CAST(CASE WHEN TEXT LIKE '%DBID%' THEN SUBSTRING(TEXT, CHARINDEX('DBID', TEXT)+ 5, CHARINDEX(' ', TEXT, CHARINDEX('DBID', TEXT)) - (CHARINDEX('DBID', TEXT)+ 5)) END AS INT)  AS DATABASE_ID  
            , CAST(CASE WHEN TEXT LIKE '%OBJID%' THEN SUBSTRING(TEXT, CHARINDEX('OBJID', TEXT)+ 6, CHARINDEX(' ', TEXT, CHARINDEX('OBJID', TEXT)) - (CHARINDEX('OBJID', TEXT)+ 6)) END  AS INT)AS OBJECT_ID
            , CAST(CASE WHEN TEXT LIKE '%HOBTID%' THEN SUBSTRING(TEXT, CHARINDEX('HOBTID', TEXT)+ 7, CHARINDEX(' ', TEXT, CHARINDEX('HOBTID', TEXT)) - (CHARINDEX('HOBTID', TEXT)+ 7)) END  AS BIGINT)AS HOBT_ID
            , CAST(CASE WHEN TEXT LIKE '%PAGEID%' THEN SUBSTRING(TEXT, CHARINDEX('PAGEID', TEXT)+ 7, CHARINDEX(' ', TEXT, CHARINDEX('PAGEID', TEXT)) - (CHARINDEX('PAGEID', TEXT)+ 7)) END  AS BIGINT)AS PAGE_ID
            , CAST(CASE WHEN TEXT LIKE '%ASSOCIATEDOBJECTID%' THEN RIGHT(TEXT, LEN(TEXT) - CHARINDEX('ASSOCIATEDOBJECTID', TEXT) -18) END  AS BIGINT) AS ASSOCIATED_OBJECT_ID
            , CAST(CASE WHEN TEXT LIKE '%OBJECTNAME%' THEN SUBSTRING(TEXT, CHARINDEX('OBJECTNAME', TEXT)+ 11, CHARINDEX(' ', TEXT, CHARINDEX('OBJECTNAME', TEXT)) - (CHARINDEX('OBJECTNAME', TEXT)+ 11)) END AS NVARCHAR(500)) AS OBJECT_NAME
            , CAST(CASE WHEN TEXT LIKE '%INDEXNAME%'  THEN SUBSTRING(TEXT, CHARINDEX('INDEXNAME' , TEXT)+ 10, CHARINDEX(' ', TEXT, CHARINDEX('INDEXNAME' , TEXT)) - (CHARINDEX('INDEXNAME' , TEXT)+ 10)) END AS SYSNAME) AS INDEX_NAME
            , TEXT
            INTO #RESOURCE_LIST
            FROM #T1222_WITH_BATCH
            WHERE ERROR_LOG_ID IN (
                                    SELECT ERROR_LOG_ID - 1
                                    FROM #T1222_WITH_BATCH
                                    WHERE TEXT LIKE '%OWNER_LIST%'
                                    )
            AND TEXT LIKE '%MODE=%'
            AND TEXT NOT LIKE '%OWNER ID=%'

            --SELECT * FROM #T1222_WITH_BATCH T
            --JOIN #RESOURCE R ON R.BATCH_ID = T.BATCH_ID AND R.BATCH_SEQUENCE_NUMBER <= T.BATCH_SEQUENCE_NUMBER
            --ORDER BY T.BATCH_ID, T.BATCH_SEQUENCE_NUMBER

            --SELECT 'DEFINITIONS AND REFERENCES FOR HOBT_ID, ETC.'
            --SELECT 'REFERENCES FOR DEADLOCK ANALYSIS'
            --SELECT 'LOCK MAY BE FROM PRIOR COMMAND IN LARGER TRANSACTION.  APP CODE REVIEW MAY BE REQUIRED.'
            --SELECT 'ASSOCIATED_OBJECT_ID MAY BE PARTITION_ID, BUT NOT SURE OF CONTEXT.  IN MOST CASES IT IS OBJECT_ID OR HOBT_ID, WHICH ARE PULLED AS DEDICATED COLUMNS.  IF ASSOCIATED_OBJECT_ID IS POPULATED, MANUAL REVIEW IS NECESSARY.'

            SELECT BATCH_ID
            , ERROR_LOG_ID
            , LOCK_TYPE
            ,LOCK_MODE
            , CAST(CASE WHEN OBJECT_NAME IS NOT NULL THEN LEFT(OBJECT_NAME, CHARINDEX('.', OBJECT_NAME)-1) END AS SYSNAME) AS DB_NAME
            , CAST(CASE WHEN OBJECT_NAME IS NOT NULL THEN SUBSTRING(OBJECT_NAME, CHARINDEX('.', OBJECT_NAME)+1, CHARINDEX('.', OBJECT_NAME, CHARINDEX('.', OBJECT_NAME)+1) - (CHARINDEX('.', OBJECT_NAME)+1 )) END AS SYSNAME)  AS SCHEMA_NAME
            , CASE WHEN OBJECT_NAME IS NOT NULL THEN RIGHT(OBJECT_NAME, LEN(OBJECT_NAME) - CHARINDEX('.', OBJECT_NAME )) END AS OBJECT_NAME
            ,INDEX_NAME 
            ,DATABASE_ID 
            ,OBJECT_ID 
            ,HOBT_ID 
            ,PAGE_ID
            ,CASE WHEN ASSOCIATED_OBJECT_ID <> OBJECT_ID AND ASSOCIATED_OBJECT_ID <> HOBT_ID THEN ASSOCIATED_OBJECT_ID ELSE NULL END AS ASSOCIATED_OBJECT_ID
            ,TEXT 
                INTO #RESOURCE_LIST2
            FROM #RESOURCE_LIST
            ORDER BY BATCH_ID, ERROR_LOG_ID

            UPDATE #RESOURCE_LIST2
            SET OBJECT_NAME = RIGHT(OBJECT_NAME, LEN(OBJECT_NAME) - CHARINDEX('.', OBJECT_NAME ))
            WHERE OBJECT_NAME IS NOT NULL

        END -- RESOURCE INFO 

        BEGIN -- FIND INDEX INFO FOR RESOURCES RELATED TO INDICES.   
            /* GET INDEX INFO - IS IT CLUSTERED? AGE OF STATS?  FRAGMENTATION LEVEL?*/
            SELECT DISTINCT DB_NAME, DATABASE_ID,  SCHEMA_NAME, OBJECT_NAME, INDEX_NAME
            INTO #INDEX1
             FROM #RESOURCE_LIST2
            WHERE INDEX_NAME IS NOT NULL
            AND DB_NAME <> 'TEMPDB'

            /* SINCE I'LL BE GOING ACROSS MULTIPLE DATABASES, AND WANT TO PULL MULTIPLE PIECES OF INFO, I'M GOING TO LOOP OVER DBS.*/

            IF OBJECT_ID(N'TEMPDB..#DB_LIST') IS NOT NULL DROP TABLE #DB_LIST
            CREATE TABLE #DB_LIST (ID INT IDENTITY(1, 1), DB_NAME SYSNAME)
            
            INSERT INTO #DB_LIST (DB_NAME) 
            SELECT DISTINCT DB_NAME FROM #INDEX1

            IF OBJECT_ID(N'TEMPDB..#INDEX_INFO') IS NOT NULL DROP TABLE #INDEX_INFO
             CREATE TABLE #INDEX_INFO
                    (
                     DB_NAME NVARCHAR(128)
                    ,SCHEMA_NAME NVARCHAR(128)
                    ,OBJECT_NAME NVARCHAR(128)
                    ,INDEX_NAME NVARCHAR(128)
                    ,PARTITION_NUMBER INT
                    ,TYPE_DESC NVARCHAR(60)
                    ,IS_PRIMARY_KEY BIT
                    ,IS_UNIQUE BIT
                    ,IS_UNIQUE_CONSTRAINT BIT
                    ,DATA_COMPRESSION_DESC NVARCHAR(60)
                    ,ROWS BIGINT
                    ,USES_LOB_STORAGE INT
                    ,USES_ROW_OVERFLOW_STORAGE INT
                    ,STATS_DATE DATETIME
                    ,IS_HYPOTHETICAL BIT
                    ,DATABASE_ID INT
                    ,OBJECT_ID INT
                    ,INDEX_ID INT
                    ,PARTITION_ID BIGINT
                    ,ROW_NUM BIGINT
                    )



            DECLARE @DB_COUNTER INT = 1
            DECLARE @MAX_DB_COUNTER INT = (SELECT MAX(ID) FROM #DB_LIST)
            DECLARE @SQL_TEXT NVARCHAR(4000)
            DECLARE @DB_NAME SYSNAME

            WHILE @DB_COUNTER <= @MAX_DB_COUNTER
                BEGIN
                    SELECT @DB_NAME = DB_NAME FROM #DB_LIST WHERE ID = @DB_COUNTER

                    SET @SQL_TEXT = 
                    'SELECT DB.NAME AS DB_NAME
                    , SCH.NAME      AS SCHEMA_NAME
                    , OBJ.NAME      AS OBJECT_NAME
                    , IND.NAME      AS INDEX_NAME
                    , P.PARTITION_NUMBER
                    , IND.TYPE_DESC
                    , IND.IS_PRIMARY_KEY
                    , IND.IS_UNIQUE
                    , IND.IS_UNIQUE_CONSTRAINT
                    , P.DATA_COMPRESSION_DESC
                    , P.ROWS
                    , CASE WHEN PS.LOB_USED_PAGE_COUNT + PS.LOB_RESERVED_PAGE_COUNT = 0 THEN 0 ELSE 1 END AS USES_LOB_STORAGE
                    , CASE WHEN PS.ROW_OVERFLOW_USED_PAGE_COUNT + PS.ROW_OVERFLOW_RESERVED_PAGE_COUNT = 0 THEN 0 ELSE 1 END AS USES_ROW_OVERFLOW_STORAGE
                    , STATS_DATE(OBJ.OBJECT_ID, IND.INDEX_ID) AS STATS_DATE
                    , IND.IS_HYPOTHETICAL
                    , DB.DATABASE_ID
                    , OBJ.OBJECT_ID
                    , IND.INDEX_ID
                    , P.PARTITION_ID
                    , ROW_NUMBER() OVER(ORDER BY IND.OBJECT_ID, IND.INDEX_ID) AS ROW_NUM
                    FROM #INDEX1 I
                    JOIN @DB_NAME.SYS.INDEXES IND ON I.INDEX_NAME = IND.NAME
                    JOIN @DB_NAME.SYS.PARTITIONS P ON P.OBJECT_ID = IND.OBJECT_ID AND P.INDEX_ID = IND.INDEX_ID
                    JOIN @DB_NAME.SYS.DM_DB_PARTITION_STATS PS ON PS.PARTITION_ID = P.PARTITION_ID
                    JOIN @DB_NAME.SYS.OBJECTS OBJ ON OBJ.OBJECT_ID = IND.OBJECT_ID AND OBJ.NAME= I.OBJECT_NAME
                    JOIN @DB_NAME.SYS.SCHEMAS SCH ON SCH.SCHEMA_ID = OBJ.SCHEMA_ID AND SCH.NAME = I.SCHEMA_NAME
                    JOIN @DB_NAME.SYS.DATABASES DB ON DB.NAME = I.DB_NAME
                    WHERE  I.DB_NAME = ''@DB_NAME'''

                    SET @SQL_TEXT = REPLACE (@SQL_TEXT, '@DB_NAME', @DB_NAME)

                    BEGIN TRY
           
                      --  PRINT @SQL_TEXT
                        INSERT INTO #INDEX_INFO
                        EXEC( @SQL_TEXT)
                    END TRY
                    BEGIN CATCH
                          SELECT
                              ERROR_NUMBER() AS ERRORNUMBER
                              ,ERROR_SEVERITY() AS ERRORSEVERITY
                              ,ERROR_STATE() AS ERRORSTATE
                              ,ERROR_PROCEDURE() AS ERRORPROCEDURE
                              ,ERROR_LINE() AS ERRORLINE
                              ,ERROR_MESSAGE() AS ERRORMESSAGE;

                    END CATCH

                    SET @DB_COUNTER = @DB_COUNTER + 1
                END


               IF OBJECT_ID(N'TEMPDB..#PHYS_STATS') IS NOT NULL DROP TABLE #PHYS_STATS
               CREATE TABLE #PHYS_STATS
               (
                  DATABASE_ID SMALLINT
               ,OBJECT_ID INT
               ,INDEX_ID INT
               ,PARTITION_NUMBER INT
               ,INDEX_TYPE_DESC NVARCHAR(60)
               ,ALLOC_UNIT_TYPE_DESC NVARCHAR(60)
               ,INDEX_DEPTH TINYINT
               ,INDEX_LEVEL TINYINT
               ,AVG_FRAGMENTATION_IN_PERCENT FLOAT(53)
               ,FRAGMENT_COUNT BIGINT
               ,AVG_FRAGMENT_SIZE_IN_PAGES FLOAT(53)
               ,PAGE_COUNT BIGINT
               ,AVG_PAGE_SPACE_USED_IN_PERCENT FLOAT(53)
               ,RECORD_COUNT BIGINT
               ,GHOST_RECORD_COUNT BIGINT
               ,VERSION_GHOST_RECORD_COUNT BIGINT
               ,MIN_RECORD_SIZE_IN_BYTES INT
               ,MAX_RECORD_SIZE_IN_BYTES INT
               ,AVG_RECORD_SIZE_IN_BYTES FLOAT(53)
               ,FORWARDED_RECORD_COUNT BIGINT
               ,COMPRESSED_PAGE_COUNT BIGINT
               )

            
            --IF @RUN_PHYS_STATS = 1 /* NOW THAT I HAVE ALL THE INDEX INFO, PULL FRAGMENTATION LEVELS*/
            --  BEGIN
            --    DECLARE @COUNTER INT = 1
            --    DECLARE @MAX_COUNTER INT
            --    SELECT @MAX_COUNTER = MAX(ROW_NUM) FROM #INDEX_INFO
            --    DECLARE @OBJ_ID INT
            --    DECLARE @DB_ID INT
            --    DECLARE @IX_ID INT

            --    WHILE @COUNTER <= @MAX_COUNTER
            --      BEGIN
            --         SELECT @OBJ_ID = OBJECT_ID 
            --            , @DB_ID = DATABASE_ID
            --            , @IX_ID = INDEX_ID
            --         FROM #INDEX_INFO WHERE ROW_NUM = @COUNTER

            --         IF @COUNTER = 1
            --            BEGIN
            --               INSERT INTO #PHYS_STATS
            --                  SELECT * 
            --                  FROM SYS.DM_DB_INDEX_PHYSICAL_STATS(@DB_ID, @OBJ_ID, @IX_ID, NULL, 'LIMITED');
            --            END
            --         ELSE
            --            BEGIN
            --               INSERT INTO #PHYS_STATS
            --                  SELECT * 
            --                  FROM SYS.DM_DB_INDEX_PHYSICAL_STATS(@DB_ID, @OBJ_ID, @IX_ID, NULL, 'LIMITED');
            --            END   
            --            SET @COUNTER = @COUNTER + 1  
            --      END
            --END -- IF @RUN_PHYS_STATS = 1
   
            /* PULL INDEX INFORMATION BACK INTO THE RESOURCE LIST*/

            IF OBJECT_ID(N'TEMPDB..#RESOURCE_LIST3') IS NOT NULL DROP TABLE #RESOURCE_LIST3

             SELECT RL.BATCH_ID
            , RL.ERROR_LOG_ID
            , RL.LOCK_TYPE
            , RL.LOCK_MODE
            , RL.SCHEMA_NAME
            , RL.OBJECT_NAME
            , RL.INDEX_NAME
            , I.PARTITION_NUMBER
            , I.TYPE_DESC AS INDEX_TYPE
            , I.IS_PRIMARY_KEY
            , I.IS_UNIQUE
            , I.IS_UNIQUE_CONSTRAINT
            , I.DATA_COMPRESSION_DESC
            , I.ROWS
            , I.USES_LOB_STORAGE
            , I.USES_ROW_OVERFLOW_STORAGE
            , I.STATS_DATE
            --, P.AVG_FRAGMENTATION_IN_PERCENT
            , I.IS_HYPOTHETICAL
            , I.DATABASE_ID
            , COALESCE(RL.OBJECT_ID, I.OBJECT_ID) AS OBJECT_ID
            , I.INDEX_ID
            , RL.HOBT_ID
            , RL.PAGE_ID
            , RL.ASSOCIATED_OBJECT_ID
            , RL.TEXT
            INTO #RESOURCE_LIST3
             FROM #RESOURCE_LIST2 RL
            LEFT JOIN #INDEX_INFO I ON RL.DB_NAME = I.DB_NAME
                                    AND RL.SCHEMA_NAME = I.SCHEMA_NAME
                                    AND RL.OBJECT_NAME = I.OBJECT_NAME
                                    AND RL.INDEX_NAME = I.INDEX_NAME
                                    AND RL.HOBT_ID = I.PARTITION_ID
            --LEFT JOIN #PHYS_STATS P ON P.DATABASE_ID = I.DATABASE_ID 
            --                        AND P.OBJECT_ID = I.OBJECT_ID
            --                        AND P.INDEX_ID = I.INDEX_ID
            --                        AND P.PARTITION_NUMBER = I.PARTITION_NUMBER

        END -- INDEX INFO


         BEGIN /* FIGURE OUT WHICH PROCESS IS VICTIM (OR NOT) SO THAT PROCS CAN BE ASSIGNED PROPERLY)*/

            IF OBJECT_ID(N'TEMPDB..#VICTIM') IS NOT NULL DROP TABLE #VICTIM
            IF OBJECT_ID(N'TEMPDB..#PROCESS_START') IS NOT NULL DROP TABLE #PROCESS_START

            SELECT BATCH_ID, ERROR_LOG_ID
            , CAST(RIGHT(TEXT, LEN(TEXT) - CHARINDEX('DEADLOCK_VICTIM', TEXT) -17)   AS NVARCHAR(50)) AS VICTIM_PROCESS
            INTO #VICTIM
            FROM #T1222_WITH_BATCH
            WHERE TEXT LIKE '%DEADLOCK VICTIM=%'

            SELECT BATCH_ID, ERROR_LOG_ID , PROCESS_ID
            INTO #PROCESS_START
            FROM #T1222_WITH_BATCH
            WHERE TEXT = '  PROCESS-LIST'

            IF OBJECT_ID(N'TEMPDB..#PROCESS_PREP') IS NOT NULL DROP TABLE #PROCESS_PREP
            SELECT * 
            , CAST(RIGHT(TEXT, LEN(TEXT) - CHARINDEX('  PROCESS-LIST', TEXT) -14)   AS NVARCHAR(4000)) AS PROCESS_DETAILS
            INTO #PROCESS_PREP
            FROM #T1222_WITH_BATCH WHERE TEXT LIKE '   PROCESS ID=%'

            IF OBJECT_ID(N'TEMPDB..#PROCESS') IS NOT NULL DROP TABLE #PROCESS
            SELECT *, LEFT(PROCESS_DETAILS, CHARINDEX(' ', PROCESS_DETAILS)) AS PROCESS
            , ROW_NUMBER() OVER(PARTITION BY BATCH_ID ORDER BY BATCH_SEQUENCE_NUMBER) AS PROCESS_NUMBER
            INTO #PROCESS
            FROM #PROCESS_PREP

            IF OBJECT_ID(N'TEMPDB..#PROCESS_RANGE') IS NOT NULL DROP TABLE #PROCESS_RANGE
            SELECT P.*, COALESCE(P2.BATCH_SEQUENCE_NUMBER - 1, 99999) AS PROCESS_END_SEQUENCE_NUMBER
            INTO #PROCESS_RANGE
            FROM #PROCESS P
            LEFT JOIN #PROCESS P2 ON P2.BATCH_ID = P.BATCH_ID
                                    AND P2.PROCESS_NUMBER = P.PROCESS_NUMBER + 1

            /* PULL OUT PROC NAMES.  THIS IS NOT VERY RIGOUROUS.  DOESN'T WORK FOR 1222, FOR EXAMPLE.  BUT, IT GETS ME A LOT TO LOOK AT QUICKLY.  */
            IF OBJECT_ID(N'TEMPDB..#FRAME_PROCNAME') IS NOT NULL DROP TABLE #FRAME_PROCNAME
            CREATE TABLE #FRAME_PROCNAME
            (
             ERROR_LOG_ID INT
            ,CREATION_DATETIME DATETIME
            ,BATCH_ID INT
            ,BATCH_SEQUENCE_ID BIGINT
            ,PROC_CALL NVARCHAR(MAX)
            )

            INSERT INTO #FRAME_PROCNAME
            SELECT ERROR_LOG_ID
            , CREATION_DATETIME
            , BATCH_ID
            , BATCH_SEQUENCE_NUMBER
            , SUBSTRING(TEXT, CHARINDEX('PROCNAME=', TEXT) + 9, CHARINDEX('LINE=', TEXT) - 14) AS PROC_CALL
            FROM #T1222_WITH_BATCH WHERE TEXT LIKE '%FRAME PROCNAME%'
            --AND BATCH_ID NOT IN (SELECT BATCH_ID FROM #T1222_BATCH WHERE TEXT  LIKE '%EADBULK%' )

            INSERT INTO #FRAME_PROCNAME
            SELECT ERROR_LOG_ID
            , CREATION_DATETIME
            , BATCH_ID
            , BATCH_SEQUENCE_NUMBER
            , 'ADHOC: ' + TEXT
            FROM #T1222_WITH_BATCH
            WHERE ERROR_LOG_ID IN (SELECT ERROR_LOG_ID + 1 FROM #FRAME_PROCNAME WHERE PROC_CALL LIKE '%ADHOC%')


            DELETE FROM #FRAME_PROCNAME WHERE PROC_CALL LIKE 'ADHOC LINE%'
            DELETE FROM #FRAME_PROCNAME WHERE PROC_CALL LIKE 'UNKNOWN LINE%'

            IF OBJECT_ID(N'TEMPDB..#FP2') IS NOT NULL DROP TABLE #FP2
            SELECT *, ROW_NUMBER() OVER(PARTITION BY BATCH_ID ORDER BY BATCH_SEQUENCE_ID) AS ROW_NUM
            INTO #FP2
             FROM #FRAME_PROCNAME
            ORDER BY BATCH_ID, BATCH_SEQUENCE_ID


         IF OBJECT_ID(N'TEMPDB..#PROCESS_PROC_1') IS NOT NULL DROP TABLE #PROCESS_PROC_1
         SELECT P.ERROR_LOG_ID
            , PROCESS_ID
            , P.CREATION_DATETIME
            , P.FILE_NBR
            , P.BATCH_ID
            , PROCESS_NUMBER
            , PROCESS
            , BATCH_SEQUENCE_NUMBER AS PROCESS_BEGIN_SEQUENCE_NUMBER
            , PROCESS_END_SEQUENCE_NUMBER
            , FP.ERROR_LOG_ID AS PROC_CALL_ERROR_LOG_ID
            , FP.BATCH_SEQUENCE_ID AS PROC_CALL_BATCH_SEQUENCE_NUMBER
            , FP.PROC_CALL
            , FP.ROW_NUM 
            , PROCESS_DETAILS
         INTO #PROCESS_PROC_1
         FROM #PROCESS_RANGE P
         JOIN #FP2 FP ON FP.BATCH_ID = P.BATCH_ID 
                        AND FP.BATCH_SEQUENCE_ID BETWEEN P.BATCH_SEQUENCE_NUMBER AND PROCESS_END_SEQUENCE_NUMBER
         ORDER BY P.BATCH_ID, P.ERROR_LOG_ID, FP.ROW_NUM

         IF OBJECT_ID(N'TEMPDB..#PROCESS_PROC2') IS NOT NULL DROP TABLE #PROCESS_PROC2
         SELECT * 
         , ROW_NUMBER() OVER(PARTITION BY BATCH_ID, PROCESS_NUMBER ORDER BY ROW_NUM DESC) AS ROWNUM2
         INTO #PROCESS_PROC2
         FROM #PROCESS_PROC_1 ORDER BY BATCH_ID, PROCESS_NUMBER, PROC_CALL_BATCH_SEQUENCE_NUMBER


         DECLARE @BATCH_COUNT INT 
         DECLARE @MAX_BATCH_COUNT INT
         DECLARE @BATCH_ID INT
         DECLARE @PROCESS_NUMBER INT
         DECLARE @PROCESS NVARCHAR(100)
         DECLARE @PROC_CALL_STACK NVARCHAR(4000)  = ''
         DECLARE @PROCESS_COUNT INT
         DECLARE @PROCESS_MAX_COUNT INT

         SELECT @BATCH_COUNT = MIN(BATCH_ID)
               , @MAX_BATCH_COUNT = MAX(BATCH_ID) FROM #PROCESS_PROC2

         IF OBJECT_ID(N'TEMPDB..#PROCESS_PROC3') IS NOT NULL DROP TABLE #PROCESS_PROC3
         CREATE TABLE #PROCESS_PROC3 (BATCH_ID INT, PROCESS_NUMBER INT, PROCESS NVARCHAR(100), PROC_CALL_STACK NVARCHAR(4000))

         WHILE @BATCH_COUNT <= @MAX_BATCH_COUNT
         BEGIN
            SELECT @BATCH_ID = MAX(BATCH_ID)
            , @PROCESS_COUNT = 1
            , @PROCESS_MAX_COUNT = MAX(PROCESS_NUMBER)
            FROM #PROCESS_PROC2
            WHERE BATCH_ID = @BATCH_COUNT
   
            WHILE @PROCESS_COUNT <= @PROCESS_MAX_COUNT
               BEGIN
                  SELECT  @PROCESS = PROCESS
                  , @PROC_CALL_STACK = @PROC_CALL_STACK + PROC_CALL + '   ----->   ' 
                  FROM #PROCESS_PROC2
                  WHERE BATCH_ID = @BATCH_ID
                  AND PROCESS_NUMBER = @PROCESS_COUNT
                  ORDER BY ROWNUM2



                  INSERT INTO #PROCESS_PROC3 SELECT @BATCH_ID, @PROCESS_COUNT, @PROCESS, @PROC_CALL_STACK  --LEFT(@PROC_CALL_STACK + '       ', LEN(@PROC_CALL_STACK) - 7)

                  SET @PROC_CALL_STACK = ''

                  SET @PROCESS_COUNT = @PROCESS_COUNT + 1
               END 

            SET @BATCH_COUNT = @BATCH_COUNT + 1
         END -- @BATCH_COUNT <= @MAX_BATCH_COUNT
      END --/* FIGURE OUT WHICH PROCESS IS VICTIM (OR NOT) SO THAT PROCS CAN BE ASSIGNED PROPERLY)*/



        --------------------------------------------------------------------------------------------------------------------------------------------

         BEGIN /* DEADLOCK OUTPUTS*/



      if @deadlock_winner_victim  = 1
         begin
            /* RETURN PROCESS AND RESOURCE INFO - MAIN OUTPUT FOR ANALYSIS*/
            SELECT  
            'DEADLOCK PROCESS AND RESOURCE' AS OUTPUT_TYPE
             , P.BATCH_ID 
            , t.CREATION_DATETIME
            , CASE WHEN V.VICTIM_PROCESS IS NOT NULL THEN 'VICTIM' ELSE 'WINNER' END AS PROCESS_ROLE
            , P.PROCESS_NUMBER
            , P.PROCESS
            , PROC_CALL_STACK
            , case when PROC_CALL_STACK like '%eadbulk%' then 1
                   else 0 end as ARCHIVING
            , LOCK_TYPE 
            , LOCK_MODE 
            --, SCHEMA_NAME 
            , OBJECT_NAME 
            , INDEX_NAME 
            --, PARTITION_NUMBER 
            , INDEX_TYPE 
            , IS_PRIMARY_KEY 
            , IS_UNIQUE 
            --, IS_UNIQUE_CONSTRAINT 
            , DATA_COMPRESSION_DESC 
            , ROWS 
            --, USES_LOB_STORAGE 
            --, USES_ROW_OVERFLOW_STORAGE 
            , STATS_DATE 
            --, AVG_FRAGMENTATION_IN_PERCENT 
            --, IS_HYPOTHETICAL 
            --, DATABASE_ID 
            --, OBJECT_ID 
            --, INDEX_ID 
            , HOBT_ID 
            , PAGE_ID 
            , ASSOCIATED_OBJECT_ID 
            , RL.TEXT AS RESOURCE_TEXT
            FROM #PROCESS_PROC3 P
            JOIN #OWNING_PROCESS_RESOURCE OPR ON OPR.BATCH_ID = P.BATCH_ID
                                                AND OPR.PROCESS_NAME = P.PROCESS
            JOIN #RESOURCE_LIST3 RL ON RL.ERROR_LOG_ID = OPR.ERROR_LOG_ID
            join #T1222_WITH_BATCH t on t.BATCH_ID = p.BATCH_ID 
                                    and t.ERROR_LOG_ID = rl.error_log_id
            LEFT JOIN #VICTIM V ON V.BATCH_ID = P.BATCH_ID AND V.VICTIM_PROCESS = P.PROCESS
            ORDER BY P.BATCH_ID, PROCESS_NUMBER
      end


           /* HEY, WE CAN FINALLY PRODUCE SOME OF THE OUTPUT*/

            /* RETURN DATA SUMMARIZED BY HOUR*/
       if @deadlocks_by_hour  = 1
         begin
           SELECT 'DEADLOCK HOURLY COUNTS' AS OUTPUT_TYPE
            ,  DOW_NAME
            , CAST(CREATION_DATETIME AS DATE) AS DEADLOCK_DATE
            , DATEPART(HOUR,  CREATION_DATETIME) AS DEADLOCK_HOUR
            , MIN(CREATION_DATETIME) AS FIRST_ENTRY
            , MAX(CREATION_DATETIME) AS LAST_ENTRY
            , COUNT(DISTINCT BATCH_ID) AS TOTAL_DEADLOCK_COUNT
            , COUNT(*) AS DETAIL_COUNT
            FROM #T1222_WITH_BATCH EL
            JOIN DBA.DBO.DIM_DATE DT ON DT.DT = CAST(CREATION_DATETIME AS DATE)
            GROUP BY  DOW_NAME
            , CAST(CREATION_DATETIME AS DATE)
            , DATEPART(HOUR,  CREATION_DATETIME)
            ORDER BY  CAST(CREATION_DATETIME AS DATE)
            , DATEPART(HOUR,  CREATION_DATETIME)
         end


            /* RETURN DATA SUMMARIZED BY PROC*/

      if @deadlocks_by_proc = 1
         begin
            IF OBJECT_ID(N'TEMPDB..#COUNTS_BY_PROC_COMBOS') IS NOT NULL DROP TABLE #COUNTS_BY_PROC_COMBOS
            SELECT  BATCH_ID, PROC_CALL
            , CAST(CREATION_DATETIME AS DATE) AS DEADLOCK_DATE
            , DATEPART(HOUR,  CREATION_DATETIME) AS DEADLOCK_HOUR
            , (SELECT PROC_CALL FROM #FP2 FP2 WHERE FP2.BATCH_ID = FP.BATCH_ID AND ROW_NUM = 2) AS PROC_CALL2

            INTO #COUNTS_BY_PROC_COMBOS
            FROM #FP2 FP
            WHERE ROW_NUM = 1

            /* RETURN DATA SUMMARIZED BY PROC*/
            SELECT  'DEADLOCK PROC COMBOS' AS OUTPUT_TYPE
            , REPLACE(REPLACE(REPLACE(LEFT(PROC_CALL, 100), CHAR(9), ' '), CHAR(10), ' '), CHAR(13), ' ')  AS QUERY_STACK_1
            , REPLACE(REPLACE(REPLACE(LEFT(PROC_CALL2, 100), CHAR(9), ' '), CHAR(10), ' '), CHAR(13), ' ') AS QUERY_STACK_2
            , case when PROC_CALL like '%eadbulk%' then 1
                   when proc_call2 like '%eadbulk%' then 1 
                   else 0 end as ARCHIVING

            , COUNT(*) AS DEADLOCK_COUNT
            FROM #COUNTS_BY_PROC_COMBOS
            GROUP BY PROC_CALL, PROC_CALL2
            , case when PROC_CALL like '%eadbulk%' then 1
                   when proc_call2 like '%eadbulk%' then 1 
                   else 0 end 

            ORDER BY PROC_CALL, PROC_CALL2
         end

            /* RETURN DATA SUMMARIZED BY HOUR AND PROC*/

      if @deadlock_by_proc_by_hour = 1
         begin
            SELECT  'DEADLOCK PROC COMBOS BY HOUR' AS OUTPUT_TYPE
            ,  DEADLOCK_DATE
            , DEADLOCK_HOUR
            , REPLACE(REPLACE(REPLACE(LEFT(PROC_CALL, 100), CHAR(9), ' '), CHAR(10), ' '), CHAR(13), ' ') AS QUERY_STACK_1
            , REPLACE(REPLACE(REPLACE(LEFT(PROC_CALL2, 100), CHAR(9), ' '), CHAR(10), ' '), CHAR(13), ' ') AS QUERY_STACK_2
            , case when PROC_CALL like '%eadbulk%' then 1
                   when proc_call2 like '%eadbulk%' then 1 
                   else 0 end as ARCHIVING
            , COUNT(*) AS DEADLOCK_COUNT
            FROM #COUNTS_BY_PROC_COMBOS
            GROUP BY PROC_CALL, PROC_CALL2, DEADLOCK_DATE, DEADLOCK_HOUR
            , case when PROC_CALL like '%eadbulk%' then 1
                   when proc_call2 like '%eadbulk%' then 1 
                   else 0 end
            ORDER BY DEADLOCK_DATE, DEADLOCK_HOUR
         end


            /* RETURN DETAILS*/
      if @deadlock_details = 1
         begin
            SELECT 'DEADLOCK DETAIL' AS OUTPUT_TYPE  
            ,BATCH_ID
            ,BATCH_SEQUENCE_NUMBER 
            ,ERROR_LOG_ID 
            ,CREATION_DATETIME 
            ,PROCESS_ID 
            ,TEXT 
            ,FILE_NBR 
            ,CATEGORY
            FROM #T1222_WITH_BATCH
            ORDER BY BATCH_ID, BATCH_SEQUENCE_NUMBER
         end
      END /* DEADLOCK OUTPUTS*/


   END --IF @SHOW_DEADLOCKS = 1  

END


