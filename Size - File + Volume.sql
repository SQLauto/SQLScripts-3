
USE Master


SET NOCOUNT ON
--------------------------------------------------------------------------------------------------
/* SELECT OUTPUT*/
DECLARE @SHOW_FILE_AND_VOLUME_FILE_SUMMARY  BIT = 1
DECLARE @SHOW_FILE_AND_VOLUME_FILE_DETAIL   BIT = 1
DECLARE @SHOW_FILE_LEVEL_ONLY               BIT = 1
DECLARE @SHOW_VOLUME_LEVEL_ONLY             BIT = 1

/* SELECT SENSITIVITY*/
DECLARE @VOLUME_WARNING_PERCENT  INT = 20
DECLARE @VOLUME_CRITICAL_PERCENT INT = 10
DECLARE @FILE_WARNING_PERCENT    INT = 20
DECLARE @FILE_CRITICAL_PERCENT   INT = 10

/* DEBUG PARMS*/
DECLARE @DEBUG_YN BIT = 1 -- WILL PRINT THE DYNAMIC SQL FOR REVIEW
DECLARE @EXEC_YN  BIT = 1 -- WILL EXECUTE THE DYNAMIC SQL.  FINAL RESULT SET IS NULL IF SET TO 0
----------------------------------------------------------------------------------------------------

DECLARE @SERVER_INSTANCE NVARCHAR(100) =  CAST(SERVERPROPERTY('SERVERNAME') AS NVARCHAR(100));


DECLARE @CAPTURE_ID INT
SELECT @CAPTURE_ID = 1--ISNULL(MAX(EVENT_ID), 0)+1 FROM DBA.DBO.DBA_SPACEUSED_BY_DB_BY_FILEGROUP

DECLARE @NOW DATETIME = GETDATE()


IF OBJECT_ID(N'TEMPDB..#DB_FILES') is not null DROP TABLE #DB_FILES
IF OBJECT_ID(N'TEMPDB..##SPACE_USED') is not null DROP TABLE ##SPACE_USED
IF OBJECT_ID(N'TEMPDB..##FILE_GROUPS') is not null DROP TABLE ##FILE_GROUPS
IF OBJECT_ID(N'TEMPDB..#VOLUME_SIZE') is not null DROP TABLE #VOLUME_SIZE
IF OBJECT_ID(N'TEMPDB..#FILE_SIZE') is not null DROP TABLE #FILE_SIZE

SELECT D.NAME              AS DB_NAME
   , D.DATABASE_ID         AS DB_ID
   , F.DATA_SPACE_ID       AS FILE_GROUP_ID
   , F.FILE_ID             AS FILE_ID
   , F.TYPE_DESC           AS FILE_TYPE_DESC
   , F.NAME                AS FILE_LOGICAL_NAME
   , F.PHYSICAL_NAME       AS FILE_PHYSICAL_NAME
   , CAST(F.SIZE * 8/1024.0 AS DECIMAL(18,2)) AS FILE_CURRENT_CAPACITY_MB
   , CAST(F.SIZE * 8/1024.0 AS DECIMAL(18,2)) AS FILE_CONFIGURED_MB
   , CASE 
      WHEN IS_PERCENT_GROWTH = 1 THEN CAST((F.SIZE * 8/1024.0  * GROWTH/100.0 ) + (F.SIZE * 8/1024.0) AS DECIMAL(18,2))
      WHEN IS_PERCENT_GROWTH = 0 THEN CAST(F.SIZE * 8/1024.0 AS DECIMAL(18,2)) + GROWTH
      END AS FILE_SIZE_AT_NEXT_GROWTH_MB
   , CASE 
      WHEN IS_PERCENT_GROWTH = 1 THEN CAST(F.SIZE * 8/1024.0 * GROWTH/100.0 AS DECIMAL(18,2))
      WHEN IS_PERCENT_GROWTH = 0 THEN GROWTH
      END AS NEXT_GROWTH_MB
   , MAX_SIZE              AS FILE_MAX_SIZE
   , GROWTH                AS FILE_GROWTH
   , IS_PERCENT_GROWTH     AS FILE_IS_PERCENT_GROWTH
   , ROW_NUMBER() OVER(ORDER BY D.NAME, F.TYPE_DESC DESC , F.NAME) AS ROW_NUM
   , QUOTENAME(d.name)     as db_quotename
   , volume_mount_point
   , logical_volume_name
   , file_system_type
   , cast(vol.total_bytes/1024.0/1024 as decimal(18, 2)) as volume_total_MB
   , cast(vol.available_bytes/1024.0/1024 as decimal(18, 2)) as volume_free_mb
   , cast((vol.total_bytes - available_bytes)/1024.0/1024 as decimal(18, 2)) as volume_used_MB
   , vol.is_read_only as volume_is_read_only
   , vol.is_compressed as volume_is_compressed
   , ROW_NUMBER() OVER(PARTITION BY VOLUME_MOUNT_POINT, LOGICAL_VOLUME_NAME ORDER BY GETDATE() ) AS VOLUME_LEVEL_METRICS_FILTER
INTO #DB_FILES
FROM SYS.MASTER_FILES F
JOIN SYS.DATABASES    D ON D.DATABASE_ID = F.DATABASE_ID
cross apply sys.dm_os_volume_stats (f.database_id, file_id) VOL
where d.state_desc= 'online'

/* MASTER FILES HAS THE CONFIGURED INITIAL SIZE FOR TEMPDB, NOT THE CURRENT SIZE.  NEED TO UPDATE 
BASED ON SYS.DATABASE_FILES.  SINCE THAT'S DB_SPECIFIC, NEED TO DO AS A SEPARATE STEP.*/

USE TEMPDB
UPDATE F
SET FILE_CURRENT_CAPACITY_MB = CAST(D.SIZE * 8/1024.0 AS DECIMAL(18,2)) 
FROM #DB_FILES F
JOIN SYS.DATABASE_FILES  D ON F.FILE_ID = D.FILE_ID
WHERE F.DB_ID = 2                                


DECLARE @COUNTER INT = 1
DECLARE @MAX_COUNTER INT
SELECT @MAX_COUNTER = MAX(ROW_NUM) FROM #DB_FILES

DECLARE @DB_NAME SYSNAME
DECLARE @FILE_ID INT
DECLARE @FILE_NAME NVARCHAR(MAX)
DECLARE @FILE_GROUP_ID INT
DECLARE @SQL_TEXT NVARCHAR(MAX)

CREATE TABLE ##SPACE_USED (DB_NAME SYSNAME, FILE_ID INT, FILE_USED_MB DECIMAL(18, 2))
CREATE TABLE ##FILE_GROUPS (DB_NAME SYSNAME, FILE_ID INT, FILE_GROUP_ID INT, FILE_GROUP_NAME SYSNAME)

WHILE @COUNTER <= @MAX_COUNTER
BEGIN

   SELECT @DB_NAME = DB_NAME, @FILE_ID = FILE_ID, @FILE_NAME = FILE_LOGICAL_NAME, @FILE_GROUP_ID = FILE_GROUP_ID
   FROM #DB_FILES
   WHERE ROW_NUM = @COUNTER

   SET @SQL_TEXT = ''

   SET @SQL_TEXT = 'USE [@DB_NAME]
                    INSERT INTO ##SPACE_USED(DB_NAME, FILE_ID, FILE_USED_MB)
                       SELECT ''[' + @DB_NAME+ ']'', ' + CAST(@FILE_ID  AS NVARCHAR(10)) 
                  + ', CAST(FILEPROPERTY(''' + @FILE_NAME + ''',''SPACEUSED'') AS DECIMAL(18, 2))/8.00 /16.00

'

SET @SQL_TEXT = REPLACE(@SQL_TEXT, '@DB_NAME', @DB_NAME)
SET @SQL_TEXT = REPLACE(@SQL_TEXT, '@FILE_ID', @FILE_ID)
SET @SQL_TEXT = REPLACE(@SQL_TEXT, '@FILE_NAME', @FILE_NAME) 

IF @DEBUG_YN = 1 
   PRINT @SQL_TEXT

IF @EXEC_YN = 1
   EXEC (@SQL_TEXT)

SET @COUNTER = @COUNTER + 1

END


SELECT 
     @CAPTURE_ID        AS CAPTURE_ID
   , CAST(@NOW AS DATE) AS CAPTURE_DATE
   , CAST(@NOW AS TIME) AS CAPTURE_TIME
   , @SERVER_INSTANCE   AS SERVER_INSTANCE
   , SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS SERVER
   , case when charindex('\', @server_instance)= 0 then @server_instance
          else REVERSE(LEFT(REVERSE(@SERVER_INSTANCE), CHARINDEX( '\' , REVERSE( @SERVER_INSTANCE)) - 1 )) end AS INSTANCE
   , VOLUME_MOUNT_POINT AS VOLUME
   , SUBSTRING(FILE_PHYSICAL_NAME, LEN(VOLUME_MOUNT_POINT) + 1, LEN(FILE_PHYSICAL_NAME) - (LEN(VOLUME_MOUNT_POINT) - 1 + CHARINDEX( '\' , REVERSE( FILE_PHYSICAL_NAME)) )) AS DIRECTORY
   , REVERSE(LEFT(REVERSE(FILE_PHYSICAL_NAME), CHARINDEX( '\' , REVERSE( FILE_PHYSICAL_NAME)) - 1 )) AS FILE_PHYSICAL_NAME
   , FILE_PHYSICAL_NAME AS FILE_PHYSICAL_NAME_FULL
   --, CASE WHEN FILE_PHYSICAL_NAME LIKE '%$%' THEN REPLACE(SUBSTRING(FILE_PHYSICAL_NAME, CHARINDEX('$', FILE_PHYSICAL_NAME) - 1,  CHARINDEX('\', FILE_PHYSICAL_NAME, CHARINDEX('$', FILE_PHYSICAL_NAME) + 3) - CHARINDEX('$', FILE_PHYSICAL_NAME) + 2 ) , '$', ':')
   --   ELSE SUBSTRING(FILE_PHYSICAL_NAME, 1,  CHARINDEX('\', FILE_PHYSICAL_NAME, 4)) END  AS VOLUME
   , F.DB_ID
   , F.DB_NAME                                                                          
   , CASE WHEN F.FILE_TYPE_DESC = 'LOG' THEN 'N/A - LOG' 
          ELSE CASE  FILEGROUP_NAME(F.FILE_GROUP_ID)
               WHEN 'PRIMARY' THEN '.PRIMARY' ELSE FILEGROUP_NAME(F.FILE_GROUP_ID)
               END
     END AS FILEGROUP_NAME
   , F.FILE_ID
   , F.FILE_LOGICAL_NAME
   , F.FILE_TYPE_DESC AS FILE_TYPE
   , F.FILE_CONFIGURED_MB
   , F.FILE_CURRENT_CAPACITY_MB
   , U.FILE_USED_MB
   , F.FILE_CURRENT_CAPACITY_MB - U.FILE_USED_MB AS FILE_FREE_MB
   , CASE WHEN F.FILE_CURRENT_CAPACITY_MB = 0 THEN 0 
          ELSE CAST(U.FILE_USED_MB/F.FILE_CURRENT_CAPACITY_MB *100 AS DECIMAL(18, 2)) END AS FILE_USED_PCT
   , CASE WHEN F.FILE_CURRENT_CAPACITY_MB = 0 THEN 0 
          ELSE CAST((F.FILE_CURRENT_CAPACITY_MB - U.FILE_USED_MB)/F.FILE_CURRENT_CAPACITY_MB *100 AS DECIMAL(18, 2)) END AS FILE_FREE_PCT
   , CASE WHEN FILE_CURRENT_CAPACITY_MB = 0 THEN 'N/A' 
          WHEN ROUND(CAST(F.FILE_CURRENT_CAPACITY_MB - U.FILE_USED_MB AS FLOAT)/F.FILE_CURRENT_CAPACITY_MB *100 , 2) <@FILE_CRITICAL_PERCENT THEN  CAST(@FILE_CRITICAL_PERCENT AS VARCHAR(10)) + '% OR LESS FREE - CHECK VOLUME ASAP'
          WHEN ROUND(CAST(F.FILE_CURRENT_CAPACITY_MB - U.FILE_USED_MB AS FLOAT)/F.FILE_CURRENT_CAPACITY_MB *100 , 2) <@FILE_WARNING_PERCENT THEN CAST(@FILE_WARNING_PERCENT AS VARCHAR(10)) + '% OR LESS FREE - WARNING' 
          ELSE 'OKAY' END AS FILE_CURRENT_STATUS
   , NEXT_GROWTH_MB
   , FILE_SIZE_AT_NEXT_GROWTH_MB
   , CASE WHEN F.FILE_MAX_SIZE <> -1 AND FILE_SIZE_AT_NEXT_GROWTH_MB > F.FILE_MAX_SIZE THEN 'NO - NEXT FILE GROWTH WILL EXCEED MAX CONFIGURED VALUE.' ELSE 'YES - Next file growth under configured max value' END AS NEXT_GROWTH_POSSIBLE

   , F.FILE_MAX_SIZE
   , F.FILE_GROWTH
   , F.FILE_IS_PERCENT_GROWTH
   , volume_total_MB 
   , volume_free_mb 
   , volume_used_MB 
   , CASE WHEN volume_total_MB = 0 THEN 0 
            ELSE ROUND(CAST(volume_free_mb AS FLOAT)/volume_total_MB *100 , 2) 
      END AS VOLUME_FREE_PCT
   , CAST(100.00 - CASE WHEN volume_total_MB = 0 THEN 0 
                        ELSE ROUND(CAST(volume_used_MB AS FLOAT)/volume_total_MB *100 , 2) 
                        END AS DECIMAL(18, 2)) AS VOLUME_USED_PCT
INTO #FILE_SIZE
FROM ##SPACE_USED U
JOIN #DB_FILES F ON F.DB_quoteNAME = U.DB_NAME 
                AND F.FILE_ID = U.FILE_ID




SELECT  SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS SERVER
      , VOLUME_MOUNT_POINT AS VOLUME
      , volume_total_MB 
      , volume_free_mb 
      , volume_used_MB 
      , CASE WHEN volume_total_MB = 0 THEN 0 
               ELSE ROUND(CAST(volume_free_mb AS FLOAT)/volume_total_MB *100 , 2) 
         END AS VOLUME_FREE_PCT
      , CAST(CASE WHEN volume_total_MB = 0 THEN 0 
                  ELSE ROUND(CAST(volume_used_MB AS FLOAT)/volume_total_MB *100 , 2) 
        END AS DECIMAL(18, 2)) AS VOLUME_USED_PCT
      , CASE WHEN volume_total_MB = 0 THEN 'N/A' 
             WHEN ROUND(CAST(volume_free_mb AS FLOAT)/volume_total_MB *100 , 2) <@VOLUME_CRITICAL_PERCENT THEN CAST(@VOLUME_CRITICAL_PERCENT AS VARCHAR(10)) +'% OR LESS FREE - CRITICAL IF FILES ALSO FULL' 
             WHEN ROUND(CAST(volume_free_mb AS FLOAT)/volume_total_MB *100 , 2) <@VOLUME_WARNING_PERCENT THEN CAST(@VOLUME_WARNING_PERCENT AS VARCHAR(10)) + '% OR LESS FREE - WARNING'
             ELSE 'OKAY' END AS VOLUME_CURRENT_STATUS
INTO #VOLUME_SIZE                                                                                             
FROM  #DB_FILES
WHERE VOLUME_LEVEL_METRICS_FILTER = 1


IF @SHOW_VOLUME_LEVEL_ONLY = 1
   BEGIN
     SELECT * FROM #VOLUME_SIZE
   END

IF @SHOW_FILE_LEVEL_ONLY = 1
   BEGIN
      SELECT * FROM #FILE_SIZE
   END

IF OBJECT_ID(N'TEMPDB..#VOLUME_FILE_COMBINED') is not null DROP TABLE #VOLUME_FILE_COMBINED
IF OBJECT_ID(N'TEMPDB..#FILE_ROLL_UP') is not null DROP TABLE #FILE_ROLL_UP

IF  @SHOW_FILE_AND_VOLUME_FILE_SUMMARY   = 1
  OR @SHOW_FILE_AND_VOLUME_FILE_DETAIL   = 1
   BEGIN
      SELECT  V.SERVER
            , F.SERVER_INSTANCE
            , V.VOLUME
            , V.VOLUME_FREE_MB
            , V.VOLUME_USED_MB
            , V.VOLUME_TOTAL_MB
            , V.VOLUME_FREE_PCT
            , V.VOLUME_USED_PCT
            , V.VOLUME_CURRENT_STATUS
            , COALESCE(F.FILE_CURRENT_STATUS, 'N/A - NO DB FILES ON VOLUME') AS FILE_CURRENT_STATUS
            , CASE WHEN F.FILE_CURRENT_STATUS IS NULL THEN V.VOLUME_CURRENT_STATUS
                   ELSE CASE WHEN V.VOLUME_CURRENT_STATUS = 'OKAY' OR F.FILE_CURRENT_STATUS = 'OKAY' THEN 'OKAY' 
                             ELSE 'POTENTIAL PROBLEM' 
                        END 
               END AS CURRENT_COMBINED_STATUS
            , DIRECTORY
            , FILE_PHYSICAL_NAME
            , F.DB_NAME
            , F.FILE_LOGICAL_NAME
            , CASE WHEN F.FILE_TYPE= 'ROWS' THEN 'DATA' ELSE F.FILE_TYPE END AS FILE_TYPE
            , F.FILE_CURRENT_CAPACITY_MB
            , F.FILE_FREE_MB
            , F.FILE_USED_PCT
            , F.FILE_FREE_PCT
            , F.FILE_SIZE_AT_NEXT_GROWTH_MB
            , F.NEXT_GROWTH_MB

            , FILE_PHYSICAL_NAME_FULL

      INTO #VOLUME_FILE_COMBINED
      FROM #VOLUME_SIZE V
      LEFT JOIN #FILE_SIZE F ON V.SERVER = F.SERVER
                            AND V.VOLUME = F.VOLUME


      SELECT 
        SERVER
      , SERVER_INSTANCE
      , VOLUME
      , MAX(VOLUME_FREE_MB)             AS VOLUME_FREE_MB
      , MAX(VOLUME_USED_MB)             AS VOLUME_USED_MB
      , MAX(VOLUME_TOTAL_MB)            AS VOLUME_TOTAL_MB  
      , MAX(VOLUME_FREE_PCT)            AS VOLUME_FREE_PCT
      , MAX(VOLUME_USED_PCT)            AS VOLUME_USED_PCT
      , MAX(VOLUME_CURRENT_STATUS)      AS VOLUME_CURRENT_STATUS 
      , COALESCE(SUM(FILE_FREE_MB), 0)  AS SUM_FILE_FREE_MB
      , SUM(FILE_CURRENT_CAPACITY_MB)   AS VOLUME_USED_BY_DB_FILES_MB
      , MAX(VOLUME_USED_MB) - COALESCE(SUM(FILE_CURRENT_CAPACITY_MB), 0) AS VOLUME_USED_NOT_BY_DB_FILES_MB
      , MAX(NEXT_GROWTH_MB) AS MAX_NEXT_FILE_GROWTH_MB
      , SUM(FILE_CURRENT_CAPACITY_MB) + MAX(NEXT_GROWTH_MB)   AS VOLUME_USED_BY_DB_FILES_AFTER_LARGEST_FILE_GROWTH_MB

      , CASE WHEN MAX(VOLUME_TOTAL_MB) = 0 THEN 0 
               ELSE CAST(CAST(MAX(VOLUME_TOTAL_MB) - MAX(VOLUME_USED_MB) - MAX(NEXT_GROWTH_MB)  AS FLOAT)/MAX(VOLUME_TOTAL_MB) *100 AS DECIMAL(18, 2)) 
         END AS VOLUME_FREE_PCT_AFTER_LARGEST_FILE_GROWTH
      , CASE WHEN MAX(VOLUME_TOTAL_MB) = 0 THEN 0 
               ELSE 100 - CAST(CAST(MAX(VOLUME_TOTAL_MB) - MAX(VOLUME_USED_MB) - MAX(NEXT_GROWTH_MB)  AS FLOAT)/MAX(VOLUME_TOTAL_MB) *100 AS DECIMAL(18, 2)) 
         END AS VOLUME_USED_PCT_AFTER_LARGEST_FILE_GROWTH
      , CASE WHEN MAX(VOLUME_TOTAL_MB) = 0 THEN 'N/A' 
               WHEN CAST(CAST(MAX(VOLUME_TOTAL_MB) - MAX(VOLUME_USED_MB) - MAX(NEXT_GROWTH_MB)  AS FLOAT)/MAX(VOLUME_TOTAL_MB) *100 AS DECIMAL(18, 2))  < 0 THEN 'CRITICAL - Volume cannot support largest next file growth.  check free space in file ASAP'
               WHEN CAST(CAST(MAX(VOLUME_TOTAL_MB) - MAX(VOLUME_USED_MB) - MAX(NEXT_GROWTH_MB)  AS FLOAT)/MAX(VOLUME_TOTAL_MB) *100 AS DECIMAL(18, 2))  < @VOLUME_CRITICAL_PERCENT THEN CAST(@VOLUME_CRITICAL_PERCENT AS VARCHAR(10)) +'% OR LESS FREE - CRITICAL IF FILE WITH LARGEST NEXT GROWTH ALSO FULL' 
               WHEN CAST(CAST(MAX(VOLUME_TOTAL_MB) - MAX(VOLUME_USED_MB) - MAX(NEXT_GROWTH_MB)  AS FLOAT)/MAX(VOLUME_TOTAL_MB) *100 AS DECIMAL(18, 2))  < @VOLUME_WARNING_PERCENT THEN CAST(@VOLUME_WARNING_PERCENT AS VARCHAR(10)) + '% OR LESS FREE - WARNING IF FILE WITH LARGEST NEXT GROWTH '
               ELSE 'OKAY' END AS VOLUME_STATUS_AFTER_LARGEST_FILE_GROWTH
      INTO #FILE_ROLL_UP
      FROM #VOLUME_FILE_COMBINED
      GROUP BY SERVER
         , SERVER_INSTANCE
         , VOLUME
      ORDER BY SERVER
         , SERVER_INSTANCE
         , VOLUME

         IF  @SHOW_FILE_AND_VOLUME_FILE_SUMMARY   = 1
            BEGIN
               SELECT  SERVER
                     , SERVER_INSTANCE
                     , VOLUME 
                     , VOLUME_CURRENT_STATUS 
                     , VOLUME_STATUS_AFTER_LARGEST_FILE_GROWTH
                     , VOLUME_TOTAL_MB  
                     , VOLUME_USED_NOT_BY_DB_FILES_MB
                     , coalesce(VOLUME_USED_BY_DB_FILES_MB, 0) as VOLUME_USED_BY_DB_FILES_MB
                     , COALESCE(VOLUME_USED_BY_DB_FILES_MB, 0) - COALESCE(SUM_FILE_FREE_MB, 0) AS DB_FILES_USED_MB
                     , SUM_FILE_FREE_MB AS DB_FILES_FREE_MB
                     , VOLUME_FREE_MB
                     , VOLUME_FREE_PCT
                     , VOLUME_USED_PCT
                     , MAX_NEXT_FILE_GROWTH_MB
                     , COALESCE(VOLUME_USED_BY_DB_FILES_AFTER_LARGEST_FILE_GROWTH_MB, 0) AS VOLUME_USED_BY_DB_FILES_AFTER_LARGEST_FILE_GROWTH_MB
                     , VOLUME_FREE_PCT_AFTER_LARGEST_FILE_GROWTH
                     , VOLUME_USED_PCT_AFTER_LARGEST_FILE_GROWTH

               FROM #FILE_ROLL_UP
            END

   
       IF @SHOW_FILE_AND_VOLUME_FILE_DETAIL = 1 
          BEGIN     
             SELECT * FROM #VOLUME_FILE_COMBINED
          END

DROP TABLE #VOLUME_FILE_COMBINED
DROP TABLE #FILE_ROLL_UP


END

SET NOCOUNT OFF



--DROP TABLE #DB_FILES
--DROP TABLE ##SPACE_USED
--DROP TABLE ##FILE_GROUPS

--DROP TABLE #VOLUME_SIZE
--DROP TABLE #FILE_SIZE



