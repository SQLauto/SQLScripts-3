


----alter PROC DBA_DYNAMIC_DELETE
----(
----     @TICKET_DESCRIPTION        NVARCHAR(1000)  =''
----   , @ONLY_RETURN_COUNT         BIT             = 1
----   , @SERVER_INSTANCE           SYSNAME         ='jaxdwsdb017\dev'
----   , @DB_NAME                   SYSNAME         ='tmsdev'
----   , @TABLE_NAME                SYSNAME         ='jjk'
----   , @ID_COLUMN                 SYSNAME         ='trip_instance_id'
----   , @WHERE_CLAUSE              NVARCHAR(1000)  ='where lane_set_id in (select lane_set_id from business_unit where business_unit_id = 25899)'
----   , @OVERRIDE_PK_RESTRICTION   bit             = 0
----   , @INNER_LOOP_SIZE           INT             = 50
----   , @OUTER_LOOP_SIZE           INT             = 50000
----   , @DECREASE_LOOP_AT_DURATION INT             = 10
----   , @INCREASE_LOOP_AT_DURATION INT             = 3   
----   , @CHANGE_LOOP_BY            INT             = 5
----   , @ALWAYS_REDUCE_IF_OVER     INT             = 20
----   , @PAUSE_SECONDS             INT             = 120              -- IF A LOOP TAKES MORE THAN @ALWAYS_RECUDE_IF_OFER, THEN THE SCRIPT WILL WAIT FOR THIS MANY SECONDS BEFORE ISSUING THE NEXT LOOP, TO LET WHATEVER ELSE WAS HAPPENING TRY TO FINISH. 
----   , @PAUSE_COUNT               INT             = 5                -- HOW MANY TIMES WILL THE SCRIPT TRY TO PAUSE BEFORE EXITING?
----   , @LOGGING_DB                NVARCHAR(128)   = 'DBA'
----   , @PERSIST_METADATA          BIT             = 1
----   , @PERSIST_LOOP_INFO         BIT             = 1
----   , @PERSIST_ID_VALUES         BIT             = 1
----   , @MAX_LIST_ITEM_COUNT       INT             = 50 
----   , @MAX_LOG_SIZE_PCT          INT             = 50
----   , @DEBUG_YN                  BIT             = 1
----)
----AS

/* WRITTEN BY JOHN KAUFFMAN
--   V1 - 6/26/12
--   Vx - 6/7/13
in version 2 (feb 29, 2016):
1. used identity, not row_number(), to populate #delete_list
2. much more aggressive drop in loop size when times go over @always_reduce_if_over
2b.  if loop_count < original @inner_loop * .2, pause for @pause_seconds, for @pause_count times.  then exit.
3. much less aggressive growth in loop size - always grow in increments of @change_loop_by
4. fix issue with log size check.  checking every 10 loops.
5.  remove some options that were never used, that just junked up the logic.
   truncate option
   transaction option
6. add loop count to output


--   PURPOSE - PROVIDE A GENERIC DELETE SCRIPT THAT  
--      1.  WRITES TO THE SCREEN AND/OR TO ENTERPRISE WATCH FOR DOCUMENTATION
--      2.  ALLOWS USER TO RUN IN A TRANSACTION OR NOT
--      3.  ALLOWS USER TO ROLLBACK OR COMMIT.
--      4.  MONITORS THE LOG AND SHUT DOWN IF IT'S TOO FULL
--      5.  MONITORS PERFORMANCE AND DYNAMICALLY ADJUST ROWS PER LOOP.
--      6.  VALIDATES THAT THE SCRIPT IS RUNNING IN THE RIGHT SERVER AND DATABASE
--      7.  ALLOWS THE USERS TO VERIFY COUNTS BEFORE EXECUTING.

--   IMPLEMENTATION - USER ENTERS PARAMETERS FOR THE PROC, AND A SCRIPT IS GENERATED.  THE SCRIPT IS
--                    PASTED INTO A NEW WINDOW.

--                    ONCE THE SCRIPT HAS BEEN PRODUCED, SOME PARAMETERS CAN BE CHANGED, BUT MANY CANNOT.
--                    THE OPTIONS ARE OUTLINED IN THE OUTPUT.

--   DOCUMENTATION IS AVAILABLE AT S:\IT\DBA\SCRIPTS\3 - Data Manipulations\DYNAMIC DELETES
--*/


------/* TEST HARNESS


DECLARE     
     @TICKET_DESCRIPTION        NVARCHAR(1000)  ='purge sample records from bigTransactionHistory '  -- TICKET NUMBER, OR GENERAL DESCRIPTION
   , @ONLY_RETURN_COUNT         BIT             = 1                -- RETURN A COUNT OF RECORDS THAT WOULD BE DELETED, BUT DON'T DELETE.  LET'S YOU CHECK THAT THE COUNTS MAKE SENSE.
   , @SERVER_INSTANCE           SYSNAME         = 'johnkauf-hp840\msft2014'
   , @DB_NAME                   SYSNAME         = 'AdventureWorks2014'
   , @TABLE_NAME                SYSNAME         = 'bigTransactionHistory'
   , @ID_COLUMN                 SYSNAME         = 'Transactionid' -- THIS NEEDS TO BE THE PK COLUMN.  SEE @OVERRIDE_PI_RESTRICTION BELOW.
   , @WHERE_CLAUSE              NVARCHAR(1000)  = 'where transactionDate <  ''''2/1/10'''''    -- MUST START WITH THE WORD 'WHERE'.  STRINGS AND DATES ARE TRICKY.  NEED 4 SINGLE QUOTES ON EACH SIDE, PLUS THE SINGLE QUOTE AT BEGINNING AND END. USE PATTERN ['where CREATION_DATETIME < ''''12/1/05'''' AND AUTHOR = ''''MARCIA XAVIER'''''].  OF COURSE, IF THERE'S A SINGLE QUOTE IN THE STRING ITSELF, YOU'LL NEED TO DOUBLE IT.
   , @OVERRIDE_PK_RESTRICTION   BIT             = 1                -- QUERY IS DESIGNED TO WORK ON TABLES WITH A SINGLE-COLUMN PK.  IF PK DOESN'T EXIST OR IF IT'S MULTI-COLUMN, YOU CAN MANUALLY EDIT THE SCRIPT THAT GETS PRODUCED, THEN SET THIS FLAG TO 1.
   , @INNER_LOOP_SIZE           INT             = 500              -- HOW MANY RECORDS WILL BE DELETED AT A TIME.  TOTAL DURATION WILL INCREASE AS @INNER_LOOP_SIZE DECREASES, BUT YOU'RE LESS LIKELY TO IMPACT BUSINESS ACTIVITY.
   , @OUTER_LOOP_SIZE           INT             = 500000           -- LEAVE THIS ALONE - OR, AT LEAST DON'T SET OVER 500k.  PULLING OUT @INNER_LOOP FROM A SET OF MILLIONS CAN BE SLOW, SO RECORDS ARE STAGED IN SETS OF 100-500k.
   , @DECREASE_LOOP_AT_DURATION INT             = 4               -- IF A DELETE TAKES MORE THAN @DECREASE_LOOP_AT_DURATION SECONDS, THE @INNER_LOOP_SIZE WILL DECREASE BY @CHANGE_LOOP_BY
   , @INCREASE_LOOP_AT_DURATION INT             = 1                -- IF A DELETE TAKES LESS THAN @INCREASE_LOOP_AT_DURATION SECONDS, THE @INNER_LOOP_SIZE WILL INCREASE BY @CHANGE_LOOP_BY
   , @CHANGE_LOOP_BY            INT             = 50               -- THE @INNER_LOOP_SIZE WILL CHANGE BY @CHANGE_LOOP_BY IF TRIGGERED BY @DECREASE_LOOP_AT_DURATION OR @INCREASE_LOOP_AT_DURATION
   , @ALWAYS_REDUCE_IF_OVER     INT             = 20               -- THE FIRST 5 LOOPS ARE OFTEN SLOW AS DATA ARE LOADED INTO CACHE, SO @DECREASE_LOOP_AT_DURATION IS IGNORED FOR THOSE FIRST 5.  HOWEVER, THE @INNER_LOOP WILL DECREMENT IN THOSE FIRST 5 LOOPS IF DURATION IS OVER @ALWAYS_REDUCE_IF_OVER
   , @PAUSE_SECONDS             INT             = 120              -- IF A LOOP TAKES MORE THAN @ALWAYS_RECUDE_IF_OFER, THEN THE SCRIPT WILL WAIT FOR THIS MANY SECONDS BEFORE ISSUING THE NEXT LOOP, TO LET WHATEVER ELSE WAS HAPPENING TRY TO FINISH. MUST BE LESS THAN 60 MINUTES.
   , @PAUSE_COUNT               INT             = 5                -- HOW MANY TIMES WILL THE SCRIPT TRY TO PAUSE BEFORE EXITING?
   , @MAX_LOG_SIZE_PCT          INT             = 50               -- QUERY WILL STOP IF LOG GROWS OVER THIS PERCENT.


-------- IF DATA MODEL TO PERSIST INFO IS AVAILABLE, THESE PARAMETERS CAN BE USED.  
   , @LOGGING_DB                NVARCHAR(128)   = ''         -- IF NOT NULL AND ANY OF THE THE @PERSIST_* PARAMETERS ARE SET TO 1, THE SCRIPT WILL ASSUME IT CAN WRITE TO THIS DB, CALLING PROCS LOCATED IN THIS DB.  DEFAULT IS 'DBA' DATABASE USED FOR COORDINATING ALL MY SCRIPTS, BUT ANY DB WILL WORK AS LONG AS YOU'VE CREATED THE TABLES AND PROCS (SEE 'ASSUMPTIONS/REQUIREMENTS' POST AT SQLJOHNKAUFFMAN.WORDPRESS.COM)  
   , @PERSIST_METADATA          BIT             = 0                -- IF RUNNING IN MATRIX SERVERS THAT CAN ACCESS ENTERPRISE WATCH, THE LOGGING PRODUCED BY THE SCRIPT IS WRITTEN BOTH TO EW AND TO THE MESSAGES TAB.
   , @PERSIST_LOOP_INFO         BIT             = 0                -- LOGS A SEPARATE MESSAGE FOR EVERY LOOP COMPLETION, E.G., "ROWS X THROUGH Y WERE DELETED.  TIME = Z SECONDS."  THESE MESSAGES ARE ALWAYS SENT TO THE SSMS MESSAGES TAB.
   , @PERSIST_ID_VALUES         BIT             = 0                -- DO YOU WANT TO SEE A LIST OF IDS THAT ARE DELETED WITH EACH LOOP?  USUALLY NOT.
   , @MAX_LIST_ITEM_COUNT       INT             = 50               -- BECAUSE ID VALUES ARE STORED IN A GENERIC LOGGING STRUCTURE, THEY'RE STORED AS CONCATENATED CSV LISTS.  YOU CAN'T DO VERY BIG LOOPS IF YOU WANT TO LOG THE SEPARATE ID VALUES.  THIS WILL OVERRIDE @INNER_LOOP_SIZE IF @PERSIST_ID_VALUES = 1
   , @DEBUG_YN                  BIT             = 1                -- GENERATE SCRIPT, RATHER THAN EXECUTING.  ONLY '1' WORKS.  THE SCRIPT IS TOO LONG TO GET SP_EXECUTESQL TO WORK!

--EXEC MASTER.DBO.DBA_DYNAMIC_DELETE @TICKET_DESCRIPTION
--                                 , @ONLY_RETURN_COUNT
--                                 , @SERVER_INSTANCE
--                                 , @DB_NAME
--                                 , @TABLE_NAME
--                                 , @ID_COLUMN
--                                 , @WHERE_CLAUSE
--                                 , @OVERRIDE_PK_RESTRICTION
--                                 , @INNER_LOOP_SIZE 
--                                 , @OUTER_LOOP_SIZE 
--                                 , @DECREASE_LOOP_AT_DURATION 
--                                 , @INCREASE_LOOP_AT_DURATION 
--                                 , @CHANGE_LOOP_BY 
--                                 , @ALWAYS_REDUCE_IF_OVER
                                 --, @PAUSE_SECONDS
                                 --, @PAUSE_COUNT
--                                 , @MAX_LOG_SIZE_PCT
--                                 , @LOGGING_DB 
--                                 , @PERSIST_METADATA
--                                 , @PERSIST_LOOP_INFO
--                                 , @PERSIST_ID_VALUES
--                                 , @MAX_LIST_ITEM_COUNT
--                                 , @DEBUG_YN               

------*/
------------------------------------------------------------------------------------
DECLARE @SQL_SETUP  NVARCHAR(4000)
DECLARE @SQL_SETUP2 NVARCHAR(4000)
DECLARE @SQL_SETUP3 NVARCHAR(4000)

DECLARE @SQL_VALIDATION  NVARCHAR(4000)
DECLARE @SQL_VALIDATION2 NVARCHAR(4000)
DECLARE @SQL_VALIDATION3 NVARCHAR(4000)
DECLARE @SQL_VALIDATION4 NVARCHAR(4000)

DECLARE @SQL_DATA_LOAD  NVARCHAR(4000)
DECLARE @SQL_DATA_LOAD2 NVARCHAR(4000)

DECLARE @SQL_LOOPING  NVARCHAR(4000)
DECLARE @SQL_LOOPING2 NVARCHAR(4000)
DECLARE @SQL_LOOPING3 NVARCHAR(4000)
DECLARE @SQL_LOOPING4 NVARCHAR(4000)
DECLARE @SQL_LOOPING5 NVARCHAR(4000)

SET @SERVER_INSTANCE = UPPER(@SERVER_INSTANCE)
SET @DB_NAME         = UPPER(@DB_NAME)
SET @TABLE_NAME      = UPPER(@TABLE_NAME)
SET @ID_COLUMN       = UPPER(@ID_COLUMN)
SET @WHERE_CLAUSE    = UPPER(@WHERE_CLAUSE)



SET @SQL_SETUP = 
'
DECLARE @ONLY_RETURN_COUNT            BIT     = <<@ONLY_RETURN_COUNT>>
DECLARE @SERVER_INSTANCE              SYSNAME = ''<<@SERVER_INSTANCE>>''
DECLARE @INNER_LOOP_SIZE              INT     = <<@INNER_LOOP_SIZE>>
DECLARE @OUTER_LOOP_SIZE              INT     = <<@OUTER_LOOP_SIZE>>
DECLARE @DECREASE_LOOP_AT_DURATION    INT     = <<@DECREASE_LOOP_AT_DURATION>>  -- SECONDS
DECLARE @INCREASE_LOOP_AT_DURATION    INT     = <<@INCREASE_LOOP_AT_DURATION>>  -- SECONDS
DECLARE @CHANGE_LOOP_BY               INT     = <<@CHANGE_LOOP_BY>> 
DECLARE @ALWAYS_REDUCE_IF_OVER        INT     = <<@ALWAYS_REDUCE_IF_OVER>>  -- SECONDS.  THE FIRST 5 LOOPS ARE NOT CHECKED AGAINST DURATION THRESHOLD B/C THEY''RE OFTEN FAIRLY SLOW.  BUT THEY STILL NEED SOME MINIMUM PERFORMANCE REQUIREMENT.
DECLARE @MAX_LIST_ITEM_COUNT          INT     = <<@MAX_LIST_ITEM_COUNT>> -- IF INNER LOOP IS OVER THIS VALUE, INDIVIDUAL IDS DELETED WILL NOT BE LOGGED.  EW HAS A 1024 CHARACTER LIMIT IN MSGS.
DECLARE @MAX_LOG_SIZE_PCT             INT     = <<@MAX_LOG_SIZE_PCT>>  
DECLARE @OVERRIDE_PK_RESTRICTION      BIT     = <<@OVERRIDE_PK_RESTRICTION>>
DECLARE @PAUSE_SECONDS                INT     = <<@PAUSE_SECONDS>>
DECLARE @PAUSE_COUNT                  INT     = <<@PAUSE_COUNT>>
/*
THE PARAMETERS BELOW CANNOT BE CHANGED IN THIS SCRIPT, AND ARE PRESENTED FOR REFERENCE. 
 YOU MUST REGENERATE THE SCRIPT VIA DYNAMIC SQL TO CHANGE THOSE VALUES.

VALIDATIONS ARE DONE AGAINST THE PARAMETER VALUES, AND SO THEY MUST REMAIN AS ACTIVE PARAMETERS.  
hOWEVER, THEIR VALUES CONTROL THE LOGIC IN THE DYNAMIC SQL SCRIPT, AND SO CHANGING THEIR VALUES HERE
WILL CAUSE POTENTIALLY PROBLEMATIC RESULTS (E.G. TRANSACTIONS WITHOUT COMMITS, WRONG TABLES SELECTED, ETC)
*/
DECLARE @TICKET_DESCRIPTION    NVARCHAR(1000)  = ''<<@TICKET_DESCRIPTION>>''
DECLARE @DB_NAME               SYSNAME         = ''<<@DB_NAME>>''
DECLARE @TABLE_NAME            SYSNAME         = ''<<@TABLE_NAME>>''
DECLARE @ID_COLUMN             SYSNAME         = ''<<@ID_COLUMN>>''
DECLARE @WHERE_CLAUSE          NVARCHAR(1000)  = ''<<@WHERE_CLAUSE>>''
DECLARE @LOGGING_DB            NVARCHAR(128)   = ''<<@LOGGING_DB>>''
DECLARE @PERSIST_METADATA      BIT             = <<@PERSIST_METADATA>> -- IF SYSTEM ISN''T DESIGNED FOR ENTERPRISE WATCH, IT COMMENTS OUT ALL THE REFERENCES TO THE PROC THAT WRITES TO EW.
DECLARE @PERSIST_LOOP_INFO     BIT             = <<@PERSIST_LOOP_INFO>> -- IF SYSTEM ISN''T DESIGNED FOR ENTERPRISE WATCH, IT COMMENTS OUT ALL THE REFERENCES TO THE PROC THAT WRITES TO EW.
DECLARE @PERSIST_ID_VALUES     BIT             = <<@PERSIST_ID_VALUES>> -- IF SYSTEM ISN''T DESIGNED FOR ENTERPRISE WATCH, IT COMMENTS OUT ALL THE REFERENCES TO THE PROC THAT WRITES TO EW.

if OBJECT_ID(''tempdb..#delete_list'') is not null drop table #delete_list
if object_id(''tempdb..#delete_list2'') is not null drop table #delete_list2

DECLARE @SCRIPT_START_DATETIME DATETIME = GETDATE()
DECLARE @SCRIPT_END_DATETIME DATETIME
DECLARE @FAILED_VALIDATION BIT = 0

' -- END OF @SQL_SETUP1
----PRINT 'DONE WITH @SQLSETUP1'
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_SETUP= REPLACE(@SQL_SETUP, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)

                                                                        
IF @PERSIST_METADATA = 0                                                   
   BEGIN
      SET @SQL_SETUP= REPLACE(@SQL_SETUP, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END

IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_SETUP
END

SET @SQL_SETUP2 = 
'

/*LOGGING VALIDATION*/
/* if no logging DB provided, set flags to comment out all the calls to logging procs*/


if coalesce(@LOGGING_DB, '''') <> ''''
   BEGIN
      DECLARE @LOGGING_SQL NVARCHAR(4000) = ''''
      DECLARE @RETURN_COUNT INT 

      IF OBJECT_ID(N''TEMPDB..#TEMP1'') is not null DROP TABLE #TEMP1
      CREATE TABLE #TEMP1 (ROW_COUNT INT)
      SET @LOGGING_SQL = ''SELECT COUNT(*) FROM <<@LOGGING_DB>>.SYS.PROCEDURES WHERE NAME = ''''USP_LOGINFO''''''

      INSERT INTO #TEMP1  EXEC (@LOGGING_SQL)
      SET @RETURN_COUNT = (SELECT SUM(ROW_COUNT) FROM #TEMP1)

      IF @RETURN_COUNT = 0
         BEGIN
            RAISERROR(''LOGGING PREREQUISITES DO NOT EXIST IN THE DATABASE LISTED IN @LOGGING_DB.  SET THE VARIABLE TO NULL, OR SET UP REQUIRED TABLES AND PROCS IN DB LISTED.  EXITING...'', 0, 1) WITH NOWAIT
            RETURN
         END
   END

IF @LOGGING_DB IS NULL 
   BEGIN
      set @PERSIST_METADATA   = 0  
      set @PERSIST_LOOP_INFO  = 0   
      set @PERSIST_ID_VALUES  = 0    
   END

/* DO NOT LOG DETAILS IF YOU ARE NOT NOT LOGGING METADATA*/
IF @PERSIST_METADATA = 0 
   BEGIN
      set @PERSIST_LOOP_INFO  = 0   
      set @PERSIST_ID_VALUES  = 0    
   END
/* LOGGING VARIABLES*/

declare @appl_name nvarchar(60)
declare @comp_name nvarchar(60)
declare @message nvarchar(1024)

SET @COMP_NAME =''AD HOC DELETE: '' + '' <<@TICKET_DESCRIPTION>>''
SET @message = ''--------------------------------------------------------------------------------------------------------------------------------------------------------------''
RAISERROR(@message, 0, 1) WITH NOWAIT 
exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message

------------------------------------------------------------------------------------
/* DISPLAY METADATA*/
------------------------------------------------------------------------------------
      SET @MESSAGE = ''STARTING DEL_ADHOC AT '' + CAST(@SCRIPT_START_DATETIME AS NVARCHAR(20))
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @MESSAGE = ''SCRIPT EXECUTED BY : '' + SUSER_SNAME() 
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @MESSAGE = ''SCRIPT EXECUTED AGAINST '' + @@SERVERNAME + ''.'' + DB_NAME() 
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @MESSAGE = ''---------------------------------------------------------------------------------------------''
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @MESSAGE = ''PARAMETERS:         ''
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 
      SET @MESSAGE = ''    DB_NAME   :       '' + @DB_NAME
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @MESSAGE = ''    TABLE_NAME:       '' + @TABLE_NAME
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @MESSAGE = ''    WHERE CLAUSE:     '' + COALESCE(CAST(@WHERE_CLAUSE  AS VARCHAR(1000)), ''NONE PROVIDED'') 
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 

' -- END OF @SQL_SETUP2
--PRINT 'DONE WITH @SQLSETUP2'

SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)

IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_SETUP2= REPLACE(@SQL_SETUP2, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END
IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_SETUP2
END

SET @SQL_SETUP3 = 
'
      SET @MESSAGE = ''    LOOP SIZE         '' + CAST(@INNER_LOOP_SIZE AS VARCHAR(5)) + '', LOADED IN SETS OF '' + CAST(@OUTER_LOOP_SIZE AS VARCHAR(10))
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @MESSAGE = ''    REDUCE LOOP BY    '' + CAST(@CHANGE_LOOP_BY AS NVARCHAR(10)) + '' IF LOOP TAKES MORE THAN '' + CAST(@DECREASE_LOOP_AT_DURATION AS NVARCHAR(10)) + '' SECONDS''
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @MESSAGE = ''    INCREASE LOOP BY  '' + CAST(@CHANGE_LOOP_BY AS NVARCHAR(10)) + '' IF LOOP TAKES LESS THAN '' + CAST(@INCREASE_LOOP_AT_DURATION AS NVARCHAR(10)) + '' SECONDS''
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 
               
      SET @MESSAGE = ''---------------------------------------------------------------------------------------------''
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @MESSAGE = ''@DECREASE_LOOP_AT_DURATION IS IGNORED FOR THE FIRST 5 LOOPS.  THE QUERY OFTEN NEEDS TO WARM UP.''
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @MESSAGE = ''HOWEVER, IF THE DURATION OF ANY LOOP IS OVER ' + CAST(@ALWAYS_REDUCE_IF_OVER AS NVARCHAR(10)) + ' SECONDS, THE QUERY WILL BACK OFF.''
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @MESSAGE = ''    FIRST, THE QUERY WILL PAUSE '+ CAST(@PAUSE_SECONDS AS NVARCHAR(10)) + ' SECONDS BEFORE TRYING THE NEXT LOOP''
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT  
 
      SET @MESSAGE = ''    THE QUERY WILL TRY PAUSING '+ CAST(@PAUSE_COUNT AS NVARCHAR(10)) + ' TIMES BEFORE EXITING.''
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT    


      SET @MESSAGE = ''-------------------------------------------------------------------------------------------------''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 


IF NOT EXISTS (SELECT * FROM MASTER.SYS.TABLES WHERE NAME = ''APPLICATION_LOG'')
   BEGIN
      SET @MESSAGE = ''INSTANCE DOES NOT SUPPORT WRITES TO ENTERPRISE WATCH.  MESSAGES WILL ONLY BE SENT TO LOCAL SCREEN''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 
   END
ELSE
   BEGIN
      SET @MESSAGE = ''INSTANCE SUPPORTS WRITES TO ENTERPRISE WATCH.  MESSAGES WILL BE SENT TO EW IF SELECTED TO DO SO.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 
   END


' -- END OF @SQL_SETUP3
--PRINT 'DONE WITH @SQLSETUP3'

SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)

IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_SETUP3= REPLACE(@SQL_SETUP3, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END
IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_SETUP3
END   
      
SET @SQL_VALIDATION = 
'
/* VALIDATIONS*/
-----------------------------------------------------------------------------------------------------------
/* AN AUTOMATIC SCRIPT TO DELETE RECORDS FROM ANY TABLE... WHAT COULD GO WRONG?
   A SERIES OF VALIDATIONS MUST BE PASSED BEFORE COMMENCING*/
-----------------------------------------------------------------------------------------------------------

SET @MESSAGE = ''---------------------------------------------------------------------------------------------''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

SET @MESSAGE = ''VALIDATIONS''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 
         
SET @MESSAGE = ''''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 


declare @pk_count int

select @pk_count = count(*) 
from sys.indexes i
join sys.index_columns c on c.index_id = i.index_id
 AND C.OBJECT_ID = I.OBJECT_ID
where is_primary_key = 1
and i.object_id = object_id (''<<@TABLE_NAME>>'')

if @pk_count = 0 AND @OVERRIDE_PK_RESTRICTION = 0
   BEGIN
      SET @MESSAGE = ''   FAILED --- TABLE DOES NOT HAVE A PRIMARY KEY. TO EXECUTE ANYWAY, SET THE @OVERRIDE_PK_RESTRICTION FLAG TO 1.  MANUAL ADJUSTMENT OF QUERY IS PROBABLY NEEDED.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @FAILED_VALIDATION = 1
   END

if @pk_count > 1 AND @OVERRIDE_PK_RESTRICTION = 0
   BEGIN
      SET @MESSAGE = ''   FAILED --- PRIMARY KEY HAS MORE THAN 1 COLUMN.  TO EXECUTE ANYWAY, SET THE @OVERRIDE_PK_RESTRICTION FLAG TO 1, AND MANUALLY ADJUST SCRIPT TO RESPECT THE FULL PK.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @FAILED_VALIDATION = 1
   END

if @pk_count <> 1 AND @OVERRIDE_PK_RESTRICTION = 1
   BEGIN
      SET @MESSAGE = ''   PASSED --- PRIMARY KEY DOES NOT HAVE A SINGLE COLUMN, BUT @OVERRIDE_PK_RESTRICTION HAS BEEN SET TO 1. BE SURE TO MANUALLY UPDATE THE SCRIPT IF NEEDED.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 

   END

IF @PK_COUNT = 1
   BEGIN
      SET @MESSAGE = ''   PASSED --- TABLE HAS A PRIMARY KEY WITH A SINGLE COLUMN.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 
   END




   
' -- END OF @SQL_VALIDATION
------PRINT 'DONE WITH @@SQL_VALIDATION'

SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)

IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_VALIDATION= REPLACE(@SQL_VALIDATION, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END
IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_VALIDATION
END

SET @SQL_VALIDATION2 = 
'
IF @SERVER_INSTANCE <> CAST(SERVERPROPERTY(''SERVERNAME'') AS SYSNAME)
   BEGIN
      SET @MESSAGE = ''   FAILED --- QUERY NOT BEING RUN AGAINST INSTANCE ENTERED AS PARAMETER.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @FAILED_VALIDATION = 1
   END
ELSE
   BEGIN
      SET @MESSAGE = ''   PASSED --- QUERY RUN AGAINST INSTANCE ENTERED AS PARAMETER.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 
   END


IF @DB_NAME <> DB_NAME()
   BEGIN
      SET @MESSAGE = ''   FAILED --- QUERY NOT BEING RUN AGAINST DATABASE ENTERED AS PARAMETER.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @FAILED_VALIDATION = 1
   END
ELSE
   BEGIN
      SET @MESSAGE = ''   PASSED --- QUERY RUN AGAINST DATABASE ENTERED AS PARAMETER.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 
   END

IF @TABLE_NAME NOT IN (SELECT NAME FROM SYS.TABLES WHERE TYPE = ''U'')
   BEGIN
      SET @MESSAGE = ''   FAILED --- TABLE DOES NOT EXIST IN DATABASE SELECTED.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @FAILED_VALIDATION = 1
   END
   BEGIN
      SET @MESSAGE = ''   PASSED --- TABLE EXISTS IN DATABASE SELECTED.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 
   END

DECLARE @CHECKSUM_ORIGINAL_DYNAMIC_PARAMETERS INT 
 
SET @CHECKSUM_ORIGINAL_DYNAMIC_PARAMETERS =  
CHECKSUM(
        ''<<@TICKET_DESCRIPTION>>'' 
      + ''<<@DB_NAME>>''       
      + ''<<@TABLE_NAME>>''            
      + ''<<@ID_COLUMN>>''             
      + ''<<@WHERE_CLAUSE>>''  
      + CAST(<<@PERSIST_METADATA>> AS NVARCHAR(1))    )   
 
DECLARE @CHECKSUM_EXEC_PARAMETERS INT 
 
SET @CHECKSUM_EXEC_PARAMETERS = 
CHECKSUM(
        @TICKET_DESCRIPTION
      + @DB_NAME       
      + @TABLE_NAME            
      + @ID_COLUMN            
      + @WHERE_CLAUSE  
      + CAST( @PERSIST_METADATA AS NVARCHAR(1))      )  
' -- END OF @SQL_VALIDATION2
------PRINT 'DONE WITH @@SQL_VALIDATION2'

SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)


IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_VALIDATION2= REPLACE(@SQL_VALIDATION2, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END
IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_VALIDATION2
END

SET @SQL_VALIDATION3 = 
'

IF @CHECKSUM_ORIGINAL_DYNAMIC_PARAMETERS <> @CHECKSUM_EXEC_PARAMETERS
   BEGIN
      SET @MESSAGE = ''   FAILED --- THE FOLLOWING PARAMETERS CAN ONLY BE CHANGED BY REGENERATING THE SCRIPT - TICKET_DESCRIPTION, TRANSACTION_NEEDED, ROLLBACK_OR_COMMIT, DB_NAME, TABLE_NAME, ID_COLUMN, WHERE_CLAUSE, TRUNCATE_ONLY, AND DOES_EW_EXIST.  RESULTS CANNOT BE TRUSTED.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @FAILED_VALIDATION = 1
   END
ELSE   
   BEGIN
      SET @MESSAGE = ''   PASSED --- STATIC VALUES PASSED TO DYNAMIC PROC MATCH VALUES EXECUTED (TICKET_DESCRIPTION, TRANSACTION_NEEDED, ROLLBACK_OR_COMMIT, DB_NAME, TABLE_NAME, ID_COLUMN, WHERE_CLAUSE, TRUNCATE_ONLY, AND DOES_EW_EXIST.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 
   END
   

IF @WHERE_CLAUSE NOT LIKE ''WHERE%''
   BEGIN
      SET @MESSAGE = ''   FAILED --- @WHERE_CLAUSE PARAMETER MUST START WITH ''''WHERE''''.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 
      
      SET @FAILED_VALIDATION = 1

   END
ELSE
   BEGIN
   SET @MESSAGE = ''   PASSED --- @WHERE_CLAUSE PARAMETER MUST START WITH ''''WHERE''''.''

   exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
   RAISERROR(@message, 0, 1) WITH NOWAIT 
END

' -- END OF @SQL_VALIDATION3
------PRINT 'DONE WITH @@SQL_VALIDATION3'

SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)


IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_VALIDATION3= REPLACE(@SQL_VALIDATION3, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END
IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_VALIDATION3
END

SET @SQL_VALIDATION4 = 
'
IF @OUTER_LOOP_SIZE > 500000
   BEGIN
      SET @MESSAGE = ''   FAILED --- FOR PERFORMANCE REASONS, PROCESS IN BATCHES OF NO MORE THAN 500,000.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 

      SET @FAILED_VALIDATION = 1
   END
ELSE
   BEGIN
      SET @MESSAGE = ''   PASSED --- FOR PERFORMANCE REASONS, PROCESS IN BATCHES OF NO MORE THAN 500,000.''

      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 
   END

DECLARE @LOG_SIZE INT = (SELECT  CNTR_VALUE
                         FROM SYS.DM_OS_PERFORMANCE_COUNTERS
                        WHERE COUNTER_NAME = ''PERCENT LOG USED ''
                        AND INSTANCE_NAME IN( ''<<@DB_NAME>>''))

IF COALESCE(@MAX_LOG_SIZE_PCT , 0) > 0
   AND @LOG_SIZE > COALESCE(@MAX_LOG_SIZE_PCT , 0)
   BEGIN
      SET @MESSAGE = ''FAILED --- <<@DB_NAME>> LOG IS '' + CAST(@LOG_SIZE AS NVARCHAR(10)) + '' PCT FULL.  RE-RUN WHEN LOG SIZE HAS REDUCED.''

      EXEC MASTER.DBO.USP_LOGSQLINFO @COMP_NAME, @MESSAGE
      RAISERROR(@MESSAGE, 0, 1) WITH NOWAIT 

      SET @FAILED_VALIDATION = 1
   END
ELSE
   BEGIN
      SET @MESSAGE = ''   PASSED --- <<@DB_NAME>> LOG IS '' + CAST(@LOG_SIZE AS NVARCHAR(10)) + '' PCT FULL.''

      EXEC MASTER.DBO.USP_LOGSQLINFO @COMP_NAME, @MESSAGE
      RAISERROR(@MESSAGE, 0, 1) WITH NOWAIT 
   END
   
   IF coalesce(@TICKET_DESCRIPTION, '''') = ''''
   BEGIN
      SET @MESSAGE = ''   FAILED --- TICKET DESCRIPTION MUST BE POPULATED.''

      EXEC MASTER.DBO.USP_LOGSQLINFO @COMP_NAME, @MESSAGE
      RAISERROR(@MESSAGE, 0, 1) WITH NOWAIT 

      SET @FAILED_VALIDATION = 1
   END
ELSE
   BEGIN
      SET @MESSAGE = ''   PASSED --- TICKET DESCRIPTION IS POPULATED.''

      EXEC MASTER.DBO.USP_LOGSQLINFO @COMP_NAME, @MESSAGE
      RAISERROR(@MESSAGE, 0, 1) WITH NOWAIT 
   END

  SET @MESSAGE = ''''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 
 
IF  @FAILED_VALIDATION = 1
BEGIN 
   SET @MESSAGE = ''VALIDATIONS FAILED.  EXITING''

   exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
   RAISERROR(@message, 0, 1) WITH NOWAIT 

   RETURN
END

SET @MESSAGE = ''VALIDATIONS PASSED.''
exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
RAISERROR(@message, 0, 1) WITH NOWAIT 

SET @message = ''----------------------------------------------------------------------------------------''
exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
RAISERROR(@message, 0, 1) WITH NOWAIT 

' -- END OF @SQL_VALIDATION4
------PRINT 'DONE WITH @@SQL_VALIDATION4'

SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)

IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_VALIDATION4= REPLACE(@SQL_VALIDATION4, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END
IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_VALIDATION4
END

SET @SQL_DATA_LOAD = 
'
-----------------------------------------------------------------------------------------------------------
/* MAIN LOGIC */
-----------------------------------------------------------------------------------------------------------

SET @MESSAGE = ''LOADING LIST OF IDs.''
exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
RAISERROR(@message, 0, 1) WITH NOWAIT 

SET @message = ''  ''
exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
RAISERROR(@message, 0, 1) WITH NOWAIT 

IF @ONLY_RETURN_COUNT = 1
   BEGIN
      SET @message = ''   @ONLY_RETURN_COUNT SET TO 1, SO ONLY COUNTS WILL BE SHOWN. NO DELETES WILL OCCUR. ''
      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 
   END



------------------------------------------------------------------------
declare @counter        int
declare @max_counter    int
-----------------------------------------------------------------------
DECLARE @END_ID         bigint
DECLARE @ROW_COUNT      bigint
DECLARE @SETS_TO_LOAD   INT
declare @start_time     datetime
declare @end_time       datetime
DECLARE @ID_VALUES      NVARCHAR(1000) = ''''

DECLARE @TOTAL_LOOP_COUNT INT = 0
DECLARE @ORIGINAL_INNER_LOOP_SIZE INT = @INNER_LOOP_SIZE
DECLARE @NEW_LOOP_SIZE INT
DECLARE @ORIGINAL_CHANGE_LOOP_BY INT = @CHANGE_LOOP_BY

DECLARE @PAUSE_HHMMSS NVARCHAR(10) = ''00:'' 
  + CASE WHEN @PAUSE_SECONDS >=60 
         THEN CASE  WHEN LEN(CAST(@PAUSE_SECONDS/60 AS NVARCHAR(2))) = 2 THEN CAST(@PAUSE_SECONDS/60 AS NVARCHAR(2))
                    WHEN LEN(CAST(@PAUSE_SECONDS/60 AS NVARCHAR(2))) = 1 THEN ''0'' + CAST(@PAUSE_SECONDS/60 AS NVARCHAR(2)) 
                    ELSE ''00'' END 
         end
 + '':'' 
 + CASE WHEN @PAUSE_SECONDS%60 = 0 THEN ''00'' 
        WHEN LEN(CAST(@PAUSE_SECONDS%60 AS NVARCHAR(10))) = 1 THEN ''0'' + CAST(@PAUSE_SECONDS%60 AS NVARCHAR(10))
        WHEN LEN(CAST(@PAUSE_SECONDS%60 AS NVARCHAR(10))) = 1 THEN CAST(@PAUSE_SECONDS%60 AS NVARCHAR(2)) end 

PRINT @PAUSE_HHMMSS


declare @inner_loop_increases int = 0
declare @inner_loop_decreases int = 0
declare @inner_loops_total    int = 0
declare @inner_loop_increase_pct float = 0
declare @inner_loop_decrease_pct float = 0

CREATE TABLE #DELETE_LIST (PK_ID int NOT NULL,  row_num int identity(1, 1)  
                             PRIMARY KEY (row_num ))   

CREATE TABLE #DELETE_LIST2 (PK_ID int NOT NULL,  row_num int not null  
                             PRIMARY KEY (row_num )) 



set nocount on

SET @ROW_COUNT = 0
SET @SETS_TO_LOAD = 0 
SET @COUNTER = 0
SET @END_ID = 0


TRUNCATE TABLE #DELETE_LIST

begin try
   INSERT  INTO #DELETE_LIST (PK_ID)
       SELECT  <<@ID_COLUMN>>  
       FROM  <<@TABLE_NAME>> (NOLOCK) t    
       <<@WHERE_CLAUSE>> 
       '
 -- END OF @SQL_DATA LOAD
----PRINT 'DONE WITH @SQL_DATA_LOAD'

-- HANDLE STRINGS AND DATES IN THE WHERE CLAUSE.  CAN'T GET THE QUOTES FOR DYNAMIC SQL ABOVE TO MATCH WITH QUOTES NEEDED IN THE INSERTION TO #DELETE_LIST
BEGIN
   DECLARE @ORIGINAL_WHERE_CLAUSE NVARCHAR(1000)

   IF  @WHERE_CLAUSE LIKE '%''''%' 
   BEGIN
   SET @ORIGINAL_WHERE_CLAUSE = @WHERE_CLAUSE
   SET @WHERE_CLAUSE= REPLACE (@WHERE_CLAUSE, '''''', '''')
   END

   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@DB_NAME>>',                  @DB_NAME)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@TABLE_NAME>>',               @TABLE_NAME)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@ID_COLUMN>>',                @ID_COLUMN)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@LOGGING_DB>>',               @LOGGING_DB)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
   SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)

   SET @WHERE_CLAUSE = @ORIGINAL_WHERE_CLAUSE
END -- HANDLE DATES AND STRINGS IN THE WHERE CLAUSE


IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_DATA_LOAD= REPLACE(@SQL_DATA_LOAD, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END

IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_DATA_LOAD
END
SET @SQL_DATA_LOAD2 = 
'
   set @row_count = @@rowcount

   if @ONLY_RETURN_COUNT = 1
      BEGIN
         SET @message = ''   FOUND '' + CAST(@ROW_COUNT AS VARCHAR(10)) + '' <<@ID_COLUMN>>'' + CASE WHEN @ROW_COUNT > 1 THEN ''S '' ELSE '' '' END + ''FROM <<@TABLE_NAME>> ELIGIBLE FOR DELETION.''
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 
      END
   ELSE
      BEGIN
         SET @message = ''   DELETING '' + CAST(@ROW_COUNT AS VARCHAR(10)) + '' <<@ID_COLUMN>>'' + CASE WHEN @ROW_COUNT > 1 THEN ''S '' ELSE '' '' END + ''FROM <<@TABLE_NAME>>.''
               exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
               RAISERROR(@message, 0, 1) WITH NOWAIT 
      END
end try
begin catch
    set @message = ''   UNABLE TO LOAD LIST OF IDs.  ERROR RETURNED: '' + ERROR_MESSAGE() 
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 
         RETURN
end catch



IF @ROW_COUNT < @OUTER_LOOP_SIZE
   BEGIN
      SET @OUTER_LOOP_SIZE = @ROW_COUNT
   END

IF @OUTER_LOOP_SIZE = 0 
   BEGIN
      SET @SETS_TO_LOAD = 0
   END
ELSE
   BEGIN
      set @sets_to_load = ceiling(@ROW_COUNT * 1.0/@OUTER_LOOP_SIZE)
   END

set @message = ''   '' 
      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 

set @message = ''   '' + CAST (@sets_to_load AS VARCHAR(6)) + '' SET'' + CASE WHEN @sets_to_load > 1 THEN ''S '' ELSE '''' END + ''OF '' + CAST(@OUTER_LOOP_SIZE AS VARCHAR(10))  + '' WILL BE PROCESSED.'' 
      exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
      RAISERROR(@message, 0, 1) WITH NOWAIT 

IF @ONLY_RETURN_COUNT = 1
   BEGIN
   
         SET @SCRIPT_END_DATETIME  = GETDATE()

         SET @message = ''   IDs WERE LOADED IN '' + CAST(DATEDIFF(S, @SCRIPT_START_DATETIME, @SCRIPT_END_DATETIME) AS NVARCHAR(10)) + '' SECONDS. ''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

         SET @message = ''  ''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

         SET @message = ''   *** PER SELECTED OPTION, ONLY COUNTS WERE RETURNED. NO DELETES OCCURRED.*** ''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

         SET @message = ''----------------------------------------------------------------------------------------''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

         SET @message = ''''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

         SET @message = ''''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

      RETURN
   END
ELSE
   BEGIN
         SET @message = ''  ''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

         SET @message = ''COMPLETED LOADING IDs. ''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

         SET @message = ''----------------------------------------------------------------------------------------''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

   END
' -- END OF @SQL_DATA LOAD2

----PRINT 'DONE WITH @SQL_DATA_LOAD2'

SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)

IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_DATA_LOAD2= REPLACE(@SQL_DATA_LOAD2, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END

IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_DATA_LOAD2
END
-----------------------------------------------------------------------------------------------------------
SET @SQL_LOOPING = 
'

/* START PROCESSING OUTER LOOP*/
' 



SET @SQL_LOOPING = @SQL_LOOPING + 

   '
         SET @message = ''BEGINNING DELETES. ''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

         SET @message = ''   ''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

   while @sets_to_load > 0 -- OUTER LOOP
         begin -- OUTER LOOP

            insert into #DELETE_LIST2
               select top (@OUTER_LOOP_SIZE) *
               from #DELETE_LIST
               order by row_num

            SET @message = ''STARTING OUTER LOOP # '' + cast(@sets_to_load as nvarchar(10)) + ''. Time = '' + CONVERT(nvarchar(60), GETDATE(), 126)
            RAISERROR('''', 0, 1) WITH NOWAIT  
            RAISERROR(''-------------------------------------------------------'', 0, 1) WITH NOWAIT
            RAISERROR(@message, 0, 1) WITH NOWAIT  
            RAISERROR('''', 0, 1) WITH NOWAIT  

            select @counter = min(row_num) from #DELETE_LIST2
            select @max_counter = max(row_num) from #DELETE_LIST2

            SET @END_ID = @counter + @INNER_LOOP_SIZE

            while @counter <= @max_counter -- INNER LOOP
               begin
                  set @start_time = getdate()            
                  SET @ID_VALUES  = ''''
                  SET @TOTAL_LOOP_COUNT = @TOTAL_LOOP_COUNT + 1

                  set @inner_loops_total = @inner_loops_total + 1

                  /* start deletes*/
                  BEGIN TRY
                     DELETE FROM <<@TABLE_NAME>> 
                     WHERE <<@ID_COLUMN>> IN (SELECT PK_ID FROM #DELETE_LIST2 WHERE ROW_NUM BETWEEN @COUNTER AND @END_ID)
                   END TRY
                   BEGIN CATCH
                      set @message = ERROR_MESSAGE() 
                           exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
                           RAISERROR(@message, 0, 1) WITH NOWAIT 

                      RETURN
                  END CATCH
                  
                  IF @PERSIST_ID_VALUES = 1 AND @INNER_LOOP_SIZE <= @MAX_LIST_ITEM_COUNT -- NO POINT LISTING IF IT''LL GET TRUCATED GOING TO EW, AND GETS MEANINGLESS WHEN YOU''RE DELETING THOUSANDS
                     BEGIN
                        SELECT @ID_VALUES = @ID_VALUES + CAST(PK_ID AS NVARCHAR(20)) + '', ''
                        from #DELETE_LIST2 
                        where row_num between @counter and @end_id
                     END

                  set @end_time = getdate()

                  SET @message = ''Loop '' + cast(@TOTAL_LOOP_COUNT as nvarchar(30)) + SPACE(10 - LEN(cast(@TOTAL_LOOP_COUNT as nvarchar(30)))) + '' Processed rows '' + CAST(@counter AS nvarchar(30)) + '' to '' + CAST(@END_ID AS nvarchar(30)) + ''. Time = '' + CONVERT(nvarchar(60),datediff(s, @start_time, @end_time)) + '' seconds''
                  RAISERROR(@message, 0, 1) WITH NOWAIT


                  IF @PERSIST_ID_VALUES = 1 AND @INNER_LOOP_SIZE <= @MAX_LIST_ITEM_COUNT -- NO POINT LISTING IF IT''LL GET TRUCATED GOING TO EW, AND GETS MEANINGLESS WHEN YOU''RE DELETING THOUSANDS
                     BEGIN
                        SET @message = ''ID VALUES DELETED:  '' + @ID_VALUES
                        RAISERROR(@message, 0, 1) WITH NOWAIT
                        IF @PERSIST_LOOP_INFO  = 1
                           BEGIN
                              RAISERROR('''', 0, 1) WITH NOWAIT -- NEED SOMETHING HERE FOR WHEN THE EW PROC IS COMMENTED OUT
                              exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
                           END  
                     END

' -- END OF @SQL_LOOPING

------PRINT 'DONE WITH @SQL_LOOPING'

SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)

IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_LOOPING= REPLACE(@SQL_LOOPING, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END

IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_LOOPING
END
-----------------------------------------------------------------------------------------------------------

SET @SQL_LOOPING2 = 
'
             -- if loops are taking longer than threshold, lower the loop count 
                  IF (@DECREASE_LOOP_AT_DURATION < datediff(s, @start_time, @end_time) AND @TOTAL_LOOP_COUNT > 5 )-- FIRST FEW LOOPS CAN BE SLOWER THAN THE REST

                     BEGIN
                        SET @MESSAGE = ''Loop size decreasing from '' + CAST(@INNER_LOOP_SIZE AS NVARCHAR(10)) + '' to '' + CAST((@INNER_LOOP_SIZE - @CHANGE_LOOP_BY) AS NVARCHAR(10)) 

                        SET @INNER_LOOP_SIZE = @INNER_LOOP_SIZE - @CHANGE_LOOP_BY

                        set @inner_loop_decreases = @inner_loop_decreases + 1

                        exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
                        RAISERROR('''', 0, 1) WITH NOWAIT -- NEED SOMETHING HERE FOR WHEN THE EW PROC IS COMMENTED OUT
                        exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
                        RAISERROR(@message, 0, 1) WITH NOWAIT 
                     END

                    IF (@INCREASE_LOOP_AT_DURATION > datediff(s, @start_time, @end_time) )
                      and ( (@PERSIST_ID_VALUES = 1 and @inner_loop_size < @MAX_LIST_ITEM_COUNT)
                           or
                             @PERSIST_ID_VALUES = 0)
                     BEGIN
                        SET @MESSAGE = ''Loop size increasing from '' + CAST(@INNER_LOOP_SIZE AS NVARCHAR(10)) + '' to '' + CAST((@INNER_LOOP_SIZE + @CHANGE_LOOP_BY) AS NVARCHAR(10)) 

                        exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
                        RAISERROR(@message, 0, 1) WITH NOWAIT 

                        SET @INNER_LOOP_SIZE = @INNER_LOOP_SIZE + @CHANGE_LOOP_BY

                        set @inner_loop_increases = @inner_loop_increases + 1

                     END

                  IF @INNER_LOOP_SIZE < 1  -- if decrease takes loop count below 1, adjust loop back to prior value, and apply half the loop reduction.  may still result in value less than 0, but it''s a decent initial attempt.
                     BEGIN
                        
                        SET @MESSAGE = ''LOOP SIZE CANNOT BE < 1.  LOOP SIZE ADJUSTING FROM '' + CAST(@INNER_LOOP_SIZE AS NVARCHAR(10)) + '' TO '' + CAST(1 AS NVARCHAR(10)) 

                        SET @INNER_LOOP_SIZE = 1

                        exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
                        RAISERROR(@message, 0, 1) WITH NOWAIT 
                     END

                  if @CHANGE_LOOP_BY < = 0 RETURN



 
' -- END OF @SQL_LOOPING2

----PRINT 'DONE WITH @SQL_LOOPING2'

SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)

IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_LOOPING2= REPLACE(@SQL_LOOPING2, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END

IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_LOOPING2
END

SET   @SQL_LOOPING3 =
'                  /* check size of log every 10 loops*/
                  IF @INNER_LOOPS_TOTAL = 10
                     begin
                        SELECT @LOG_SIZE =  CNTR_VALUE
                        FROM SYS.DM_OS_PERFORMANCE_COUNTERS
                        WHERE COUNTER_NAME = ''PERCENT LOG USED ''
                        AND INSTANCE_NAME IN( ''<<@DB_NAME>>'')

                        IF COALESCE(@MAX_LOG_SIZE_PCT , 0) > 0
                           AND @LOG_SIZE > COALESCE(@MAX_LOG_SIZE_PCT , 0)
                           BEGIN
                              SET @MESSAGE  = ''EVERY 10 LOOPS CHECK: <<@DB_NAME>> LOG IS '' + CAST(@LOG_SIZE AS NVARCHAR(10)) + '' PCT FULL. EXITING.  RE-RUN WHEN LOG SIZE HAS REDUCED.''

                              EXEC MASTER.DBO.USP_LOGSQLINFO @COMP_NAME, @MESSAGE
                              RAISERROR('''', 0, 1) WITH NOWAIT 
                              RAISERROR(@MESSAGE, 0, 1) WITH NOWAIT 

                              RETURN
                           END -- msg about log if too full
                        else
                           BEGIN
                              SET @MESSAGE  = ''EVERY 10 LOOPS CHECK: <<@DB_NAME>> log is '' + CAST(@LOG_SIZE AS NVARCHAR(10)) + '' pct full, which is less than the value provided in @MAX_LOG_SIZE_PCT. Continuing to process.''

                              EXEC MASTER.DBO.USP_LOGSQLINFO @COMP_NAME, @MESSAGE
                              RAISERROR('''', 0, 1) WITH NOWAIT 
                              RAISERROR(@MESSAGE, 0, 1) WITH NOWAIT 
                           END -- msg about log OK

                  -- EVERY 10 LOOPS, CHECK THE TOTAL NUMBER OF INCREASES AND DECREASES.  
                  -- If PERFORMANCE IS GOOD, INCREASE LOOP SIZE.

                  IF @INNER_LOOPS_TOTAL = 10 AND (@INNER_LOOP_DECREASES = 0 and @INNER_LOOP_INCREASES >= 7)
                     BEGIN
                        SET @MESSAGE = ''                      @CHANGE_LOOP_BY parameter changing from '' + CAST(@CHANGE_LOOP_BY AS NVARCHAR(10)) + '' to '' + CAST(( @CHANGE_LOOP_BY + @ORIGINAL_CHANGE_LOOP_BY) AS NVARCHAR(10)) + '' because the last 10 loops have had no decreases and at least 7 increases. (''  + cast(@INNER_LOOP_INCREASES  as nvarchar(5))   + '' increases) ''

                        exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
                        RAISERROR(@message, 0, 1) WITH NOWAIT
                        RAISERROR('''', 0, 1) WITH NOWAIT 

                        SET @CHANGE_LOOP_BY = @CHANGE_LOOP_BY + @ORIGINAL_CHANGE_LOOP_BY  
                     END


                  IF @INNER_LOOPS_TOTAL = 10 AND (@INNER_LOOP_DECREASES >= 3 )
                     BEGIN
                        SET @MESSAGE = ''                      @CHANGE_LOOP_BY parameter changing from '' + CAST(@CHANGE_LOOP_BY AS NVARCHAR(10)) + '' to '' + CAST(( @CHANGE_LOOP_BY - @ORIGINAL_CHANGE_LOOP_BY) AS NVARCHAR(10)) + '' because the last 10 loops had at least 3 decreases. (''  + cast(@INNER_LOOP_DECREASES  as nvarchar(5))   + '' decreases) ''

                        exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
                        RAISERROR(@message, 0, 1) WITH NOWAIT
                        RAISERROR('''', 0, 1) WITH NOWAIT 

                        SET @CHANGE_LOOP_BY = @CHANGE_LOOP_BY - @ORIGINAL_CHANGE_LOOP_BY  
                     END

                        set @INNER_LOOP_DECREASES = 0
                        set @INNER_LOOP_inCREASES = 0
                        set @INNER_LOOPS_TOTAL    = 0                 
                     END
         
' 


 -- END OF @SQL_LOOPING3

----PRINT 'DONE WITH @SQL_LOOPING3'

SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)

IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_LOOPING3= REPLACE(@SQL_LOOPING3, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END

IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_LOOPING3
END

SET @SQL_LOOPING4 = 
'
            -- if loops are taking longer than @ALWAYS_REDUCE_IF_OVER, then drop counter back to the lower of original inner loop value or current value / 2. 
            --  pause for @pause_seconds.  only do this @pause_count times, then exit.
            -- if current value <=10, set @pause_count = 1
                                

                  IF ((datediff(s, @start_time, @end_time) > @ALWAYS_REDUCE_IF_OVER) AND @PAUSE_COUNT > 0  )-- FIRST FEW LOOPS CAN BE SLOWER THAN THE REST

                     BEGIN
                        SET @MESSAGE = ''LOOP DURATION WAS OVER THE '' + CAST(@ALWAYS_REDUCE_IF_OVER  AS NVARCHAR(10)) + '' SECOND THRESHOLD SET BY THE ALWAYS_REDUCE_IF_OVER PARAMETER.''

                        exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
                        RAISERROR('''', 0, 1) WITH NOWAIT -- NEED SOMETHING HERE FOR WHEN THE EW PROC IS COMMENTED OUT
                        RAISERROR(@message, 0, 1) WITH NOWAIT 


                        IF @INNER_LOOP_SIZE <=10 AND @PAUSE_COUNT > 1
                           BEGIN
                              SET @PAUSE_COUNT = 1
                           END 
                        SELECT @NEW_LOOP_SIZE = CASE WHEN @INNER_LOOP_SIZE / 2 < @ORIGINAL_INNER_LOOP_SIZE   
                                                     THEN @INNER_LOOP_SIZE / 2  
                                                     ELSE @ORIGINAL_INNER_LOOP_SIZE END
  
                        SET @MESSAGE = ''Loop size decreasing from '' + CAST(@INNER_LOOP_SIZE AS NVARCHAR(10)) + '' to '' + CAST((@NEW_LOOP_SIZE) AS NVARCHAR(10)) 

                        exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
                        RAISERROR('''', 0, 1) WITH NOWAIT -- NEED SOMETHING HERE FOR WHEN THE EW PROC IS COMMENTED OUT
                        RAISERROR(@message, 0, 1) WITH NOWAIT 

                        SET @INNER_LOOP_SIZE = @NEW_LOOP_SIZE

                        IF @PAUSE_COUNT > 0 
                           BEGIN
                              SET @MESSAGE = ''Loops pausing for '' + cast(@pause_seconds as nvarchar(30)) + '' seconds. ''
                              exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
                              RAISERROR('''', 0, 1) WITH NOWAIT -- NEED SOMETHING HERE FOR WHEN THE EW PROC IS COMMENTED OUT
                              RAISERROR(@message, 0, 1) WITH NOWAIT 

                              WAITFOR DELAY @PAUSE_HHMMSS
                           END

                        SET @MESSAGE = ''THE SCRIPT WILL PAUSE '' + CAST(@PAUSE_COUNT - 1  AS NVARCHAR(10)) + '' MORE TIMES BEFORE EXITING.''

                        exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
                        RAISERROR(@message, 0, 1) WITH NOWAIT 
                        RAISERROR('''', 0, 1) WITH NOWAIT -- NEED SOMETHING HERE FOR WHEN THE EW PROC IS COMMENTED OUT

                        SET @PAUSE_COUNT = @PAUSE_COUNT - 1

                        set @inner_loop_decreases = @inner_loop_decreases + 1

                        if @pause_count = 0
                           begin
                              return
                           end 
              
                     END


'
 -- END OF @SQL_LOOPING4

----PRINT 'DONE WITH @SQL_LOOPING4'

SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)

IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_LOOPING4= REPLACE(@SQL_LOOPING4, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END

IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_LOOPING4
END

SET @SQL_LOOPING5 = 
'

                   SET @counter = @END_ID +1
                   SET @END_ID = @counter + @INNER_LOOP_SIZE-1
               end --  INNER LOOP - ROWS TO PURGE

            delete from #DELETE_LIST where row_num < (select MAX(row_num) from #DELETE_LIST2)

            truncate  table #DELETE_LIST2

            set @sets_to_load = @sets_to_load - 1

         end -- OUTER LOOP -- @SETS_TO_LOAD LOOP

         SET @SCRIPT_END_DATETIME  = GETDATE()

         SET @message = ''COMPLETED DELETES IN '' + CAST(DATEDIFF(S, @SCRIPT_START_DATETIME, @SCRIPT_END_DATETIME) AS NVARCHAR(10)) + '' SECONDS.''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

         SET @message = ''----------------------------------------------------------------------------------------''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

         SET @message = ''''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 

         SET @message = ''''
         exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message
         RAISERROR(@message, 0, 1) WITH NOWAIT 
         
         DROP TABLE #DELETE_LIST
         DROP TABLE #DELETE_LIST2
'
 -- END OF @SQL_LOOPING5

----PRINT 'DONE WITH @SQL_LOOPING5'

SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@TICKET_DESCRIPTION>>',       @TICKET_DESCRIPTION)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@ONLY_RETURN_COUNT>>',        @ONLY_RETURN_COUNT)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@SERVER_INSTANCE>>',          @SERVER_INSTANCE)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@DB_NAME>>',                  @DB_NAME)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@TABLE_NAME>>',               @TABLE_NAME)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@ID_COLUMN>>',                @ID_COLUMN)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@WHERE_CLAUSE>>',             COALESCE(@WHERE_CLAUSE,'NULL'))
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@OVERRIDE_PK_RESTRICTION>>',  @OVERRIDE_PK_RESTRICTION)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@INNER_LOOP_SIZE>>',          @INNER_LOOP_SIZE)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@OUTER_LOOP_SIZE>>',          @OUTER_LOOP_SIZE)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@DECREASE_LOOP_AT_DURATION>>',@DECREASE_LOOP_AT_DURATION)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@INCREASE_LOOP_AT_DURATION>>',@INCREASE_LOOP_AT_DURATION)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@CHANGE_LOOP_BY>>' ,          @CHANGE_LOOP_BY)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@ALWAYS_REDUCE_IF_OVER>>',    @ALWAYS_REDUCE_IF_OVER)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@PAUSE_SECONDS>>' ,           @PAUSE_SECONDS)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@PAUSE_COUNT>>' ,             @PAUSE_COUNT)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@LOGGING_DB>>',               @LOGGING_DB)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@PERSIST_METADATA>> ',        @PERSIST_METADATA)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@PERSIST_LOOP_INFO>>',        @PERSIST_LOOP_INFO)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@PERSIST_ID_VALUES>>',        @PERSIST_ID_VALUES)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@MAX_LOG_SIZE_PCT>>',         @MAX_LOG_SIZE_PCT)
SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, '<<@MAX_LIST_ITEM_COUNT>>',      @MAX_LIST_ITEM_COUNT)

IF @PERSIST_METADATA = 0
   BEGIN
      SET @SQL_LOOPING5= REPLACE(@SQL_LOOPING5, 'exec master.dbo.usp_LogSQLInfo @COMP_NAME, @message', '')
   END

IF @DEBUG_YN = 1
BEGIN
PRINT @SQL_LOOPING5
END

--SELECT LEN(@SQL_SETUP)
--SELECT LEN(@SQL_SETUP2)
--SELECT LEN(@SQL_SETUP3)
--SELECT LEN(@SQL_VALIDATION)
--SELECT LEN(@SQL_VALIDATION2)
--SELECT LEN(@SQL_VALIDATION3)
--SELECT LEN(@SQL_VALIDATION4)

--SELECT LEN(@SQL_DATA_LOAD)
--SELECT LEN(@SQL_LOOPING)
--SELECT LEN(@SQL_LOOPING2)
--SELECT LEN(@SQL_LOOPING3)
--SELECT LEN(@SQL_LOOPING4)
--SELECT LEN(@SQL_LOOPING5)
-------------------------------------------------------------------------------------------------------------
IF @DEBUG_YN = 0
BEGIN
DECLARE @ALL_SQL NVARCHAR(MAX)
SET @ALL_SQL = @SQL_SETUP + @SQL_SETUP2 + @SQL_SETUP3 
                 + @SQL_VALIDATION + @SQL_VALIDATION2 + @SQL_VALIDATION3 + @SQL_VALIDATION4
                 + @SQL_DATA_LOAD 
                 + @SQL_LOOPING + @SQL_LOOPING2 + @SQL_LOOPING3 + @SQL_LOOPING4 + @sql_looping5

EXEC (@ALL_SQL)
END
